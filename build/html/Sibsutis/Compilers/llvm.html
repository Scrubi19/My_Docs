

<!DOCTYPE html>
<html class="writer-html5" lang="ru" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>LLVM: инфраструктура для разработки компилятора &mdash; Документация My_Docs 0.0.1</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/main.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Алфавитный указатель" href="../../genindex.html" />
    <link rel="search" title="Поиск" href="../../search.html" />
    <link rel="next" title="Ruby on Rails" href="../Ruby/ruby.html" />
    <link rel="prev" title="Криптографические методы защиты информации" href="../Crypto/cryptography.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #343131" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/logo2.svg" class="logo" alt="Логотип"/>
          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Поиск в документации" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Cheat_sheets/cheat.html">Шпаргалки</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Cheat_sheets/cheat.html#git">Git</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Cheat_sheets/cheat.html#id2">Создание репозитория</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Cheat_sheets/cheat.html#id3">Команды</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Cheat_sheets/cheat.html#gitignore">Памятка по .gitignore</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Cheat_sheets/cheat.html#bash">BASH</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Cheat_sheets/cheat.html#id5">Команды</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Cheat_sheets/cheat.html#id6">Переменные и параметры скрипта</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Cheat_sheets/cheat.html#id7">Зарезервированные переменные</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Cheat_sheets/cheat.html#id8">Условия</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Crypto/cryptography.html">Криптографические методы защиты информации</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Crypto/cryptography.html#id2">Глава 1. Криптосистемы с открытым ключом</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Crypto/cryptography.html#id3">Быстрое возведение в степень по модулю</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Crypto/cryptography.html#id4">Элементы теории чисел</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Crypto/cryptography.html#id5">Обобщенный алгоритм Эвклида</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Crypto/cryptography.html#id6">Система Диффи-Хеллмана</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Crypto/cryptography.html#id7">Шифр Шамира</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Crypto/cryptography.html#id8">Шифр Эль Гамаля</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Crypto/cryptography.html#rsa">Шифр RSA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Crypto/cryptography.html#id9">Шифр Вернама</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Crypto/cryptography.html#id10">Глава 2. Методы взлома шифров, основанных на дискретном логарифмировании</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Crypto/cryptography.html#id11">Метод «шаг младенца, шаг великана»</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Crypto/cryptography.html#id12">Глава 3. Электронная, или цифровая подпись</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Crypto/cryptography.html#id13">Электронная подпись RSA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Crypto/cryptography.html#id14">Электронная подпись на базе шифра Эль-Гамаля</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Crypto/cryptography.html#id15">Стандарты на цифровую подпись (ГОСТ Р34.10-94)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Crypto/cryptography.html#id16">Используемая литература</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">LLVM: инфраструктура для разработки компилятора</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">Установка LLVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">Инструменты и организация</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">LLVM сегодня</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Взаимодействие с драйвером компилятора</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">Использование автономных инструментов</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">Как это работает?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-llvm">Приемы программирования на C++ в LLVM</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">Демонстрация расширяемого интерфейса проходов</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tablegen-td">TableGen(.td)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id10">Анализатор исходного кода</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id11">Лексический анализ</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#clang-libtoling">Инструменты Clang и фреймворк LibToling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#clang-tidy">Clang-tidy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clang-modernizer">Clang Modernizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clang-apply-replacements">Clang Apply Replacements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clangformat">ClangFormat</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modularize">Modularize</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-map-checker">Module Map Checker</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pptrace">PPTrace</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clang-query">Clang-Query</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clang-check">Clang-Check</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-str">Удаление вызовов c_str() «Самый маленький инструмент для рефакторинга»</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#libclang">Создание собственного инструмента (libclang)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#llvm-ir">LLVM IR</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ll">Содержание .ll файла</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">Определение функций в .ll</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">Атрибуты</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">Инструкции</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id15">Оптимизации времени компиляции и времени компоновки</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16">Используемая литература</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Ruby/ruby.html">Ruby on Rails</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Ruby/ruby.html#ubuntu">Установка на Ubuntu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Ruby/ruby.html#id1">Начало</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Databases/Databases.html">Базы данных</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Databases/Databases.html#id2">Реляционные базы данных. Операции в реляционной алгебре</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../Databases/Databases.html#id3">Выборка</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Databases/Databases.html#id4">Проекция</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Databases/Databases.html#id5">Соединение и естественное соединение</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Databases/Databases.html#id6">Объединение</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Databases/Databases.html#id7">Пересечение</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Databases/Databases.html#id8">Удаление</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Databases/Databases.html#id9">Декартово произведение</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Databases/Databases.html#sql-structed-query-language">SQL(Structed Query Language)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../Databases/Databases.html#id10">Нереляционные базы данных</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Databases/Databases.html#id11">Используемая литература</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">My_Docs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>LLVM: инфраструктура для разработки компилятора</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/Sibsutis/Compilers/llvm.rst.txt" rel="nofollow"> Просмотреть исходный код страницы</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="llvm">
<h1>LLVM: инфраструктура для разработки компилятора<a class="headerlink" href="#llvm" title="Ссылка на этот заголовок">¶</a></h1>
<div class="section" id="id1">
<h2>Установка LLVM<a class="headerlink" href="#id1" title="Ссылка на этот заголовок">¶</a></h2>
<ul class="simple">
<li><p>Склонировать репозиторий с LLVM:</p></li>
</ul>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">llvm</span><span class="o">-</span><span class="n">project</span><span class="o">.</span><span class="n">git</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li><p>Конфигурирование сборочных файлов:</p></li>
</ul>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">llvm</span><span class="o">-</span><span class="n">project</span>

<span class="n">mkdir</span> <span class="n">build</span>

<span class="n">cd</span> <span class="n">build</span>

<span class="n">cmake</span> <span class="o">-</span><span class="n">G</span> <span class="o">&lt;</span><span class="n">generator</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span> <span class="o">../</span><span class="n">llvm</span>
</pre></div>
</div>
<p>Generators:</p>
<blockquote>
<div><p>Ninja — для генерации ninja-build сборочных файлов</p>
<p>Unix Makefiles — для генерации make поддерживающих parallel makefiles</p>
<p>Visual Studio — for generating Visual Studio projects and solutions</p>
<p>Xcode — for generating Xcode projects</p>
</div></blockquote>
<p>Options:</p>
<blockquote>
<div><p>-DLLVM_ENABLE_PROJECTS = „…“ — semicolon-separated list of the LLVM subprojects you’d like to additionally build. Can include any of: clang, clang-tools-extra, libcxx, libcxxabi, libunwind, lldb, compiler-rt, lld, polly, or debuginfo-tests</p>
<p><em>For example</em> : -DLLVM_ENABLE_PROJECTS=»clang;libcxx;libcxxabi»</p>
<p>-DCMAKE_INSTALL_PREFIX=directory — Specify for directory the full pathname of where you want the LLVM tools and libraries to be installed (default /usr/local)</p>
<p>-DCMAKE_BUILD_TYPE=type — Valid options for type are Debug, Release, RelWithDebInfo, and MinSizeRel. Default is Debug.</p>
<p>-DLLVM_ENABLE_ASSERTIONS=On — Compile with assertion checks enabled (default is Yes for Debug builds, No for all other build types)</p>
</div></blockquote>
</div></blockquote>
<ul class="simple">
<li><p>Запуск сборки:</p></li>
</ul>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cmake</span> <span class="o">--</span><span class="n">build</span> <span class="o">.</span>
<span class="n">cmake</span> <span class="o">--</span><span class="n">build</span> <span class="o">--</span><span class="n">target</span> <span class="n">install</span>
</pre></div>
</div>
</div></blockquote>
<p>Примечания:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Собирать на каком-либо теге</p></li>
<li><p>Можно выкачивать не весь репозиторий, см. опцию - -depth в гите</p></li>
<li><p>При сборке нужно включить проект clang в -DLLVM_ENABLE_PROJECTS</p></li>
<li><p>Собирать Debug версию (по умолчанию)</p></li>
<li><p>Для сборки мне понадоби лось 8 GB Ram + 50 GB файлов подкачки + 70 GB свободного места</p></li>
<li><p>Требуется cmake &gt;= 3.13.4, python &gt;= 2.7, gcc &gt;= 5.1.0, ninja-build</p></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="id2">
<h2>Инструменты и организация<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h2>
<p>Проект LLVM включает несколько библиотек и инструментов, которые, все вместе, образуют больщую инфраструктуру компилятора. Философия LLVM «все сущее есть библиотека». Это фреймворк со множеством инструментов позволяющий изучать/проходить все стадии компиляции</p>
<p><strong>10 лет тому назад</strong> реализация, в значительной степени состоящая из алгоритмов трансляции в машинный код, опиралась на GCC, для трансляции программ в промежуточное представление LLVM (IR)</p>
<p>В философии LLVM есть важный аспект, компилятор (clang) не применяет оптимизаций во время компиляции, оставляя возможность выполнения оптимизаций в то время, когда программа не работает (н: во время компоновки)</p>
<p><strong>Конкуренция с Java</strong>  Для поддержки оптимизации на всем жизненном цикле программы необходимо их распространение в формате LLVM IR, это предполагает работу LLVM как виртуальной машины и конкуренцию с Java</p>
<p><strong>Но</strong> LLVM IR(внутреннее представление) не является системно-независимой, к тому же в LLVM отсутствует оптимизация с обратной связью</p>
<div class="section" id="id3">
<h3>LLVM сегодня<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h3>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/structure.png"><img alt="../../_images/structure.png" src="../../_images/structure.png" style="width: 600px;" /></a>
</div>
<p>Части инфраструктуры:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Анализатор исходного кода (frontend «clang»):</strong> Компилятор, выполняющий этап трансляции программ на языках C, C++,.. в промежуточное представление LLVM IR. Включает лексический, синтаксический и семантический анализаторы, а также генератор кода LLVM IR</p></li>
<li><p><strong>Промежуточное представление (IR):</strong> Промежуточное представление LLVM IR имеет две формы: удобночитаемую текстовую форму и двоичную</p></li>
<li><p><strong>Генератор выполняемого кода (backend «asm, JIT»):</strong> Компилятор, преобразующий промежуточное представление LLVM IR программы в конкретный код на языке ассемблера для заданной архитектуры или в двоичный объектный код.</p></li>
</ul>
</div></blockquote>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/deep_structure.png"><img alt="../../_images/deep_structure.png" src="../../_images/deep_structure.png" style="width: 600px;" /></a>
</div>
<p>Все компоненты компилятора взаимодействуют друг с другом 2-мя способами:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><strong>Через структуры в памяти:</strong> Clang использует каждый компонент LLVM как библиотеку и опирается на структуру данных в памяти</p></li>
<li><p><strong>Через файлы:</strong> Пользователь запускает отдельные инструменты и использует их выходные файлы как входные файлы для последующих инструментов</p></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="id4">
<h3>Взаимодействие с драйвером компилятора<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h3>
<p>Драйвер компилятора можно сравнить с официантом в ресторане, он принимает ваш заказ, передёт его повару и затем приносит готовое блюдо. В LLVM и Clang функции драйвера компилятора выполняет инструмент <em>clang</em></p>
<p>Чтобы увидеть, какие инструменты вызываются драйвером, добавьте команду-аргумент -###</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang -### hello.c -o hello
clang version <span class="m">3</span>.4 <span class="o">(</span>tags/RELEASE_34/final <span class="m">211335</span><span class="o">)</span>
Target: i386-pc-linux-gui
Thread model: posix
“clang” “-cc1” <span class="o">(</span>...parameters<span class="o">)</span> “hello.c” “-o” “/tmp/hello-dddafc1.o”
“/usr/bin/ld” <span class="o">(</span>...parameters<span class="o">)</span> “/tmp/hello-dddafc1.o” “-o” “hello”
</pre></div>
</div>
<ul class="simple">
<li><p>clang -cc1 реализует весь цикл компиляции</p></li>
</ul>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/clang.png"><img alt="../../_images/clang.png" src="../../_images/clang.png" style="width: 600px;" /></a>
</div>
</div>
<div class="section" id="id5">
<h3>Использование автономных инструментов<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h3>
<p>Тот же самый процесс компиляции, можно выполнить с использованием автономных инструментов LLVM, передавая вывод одного инструмента на ввод другого. Скорость компиляции уменьшится, но появляется возможность тонкой настройки параметров промежуточных инструментов:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>opt:</strong> выполняет оптимизацию программы на уровне промежуточного представления IR. На входе файл с биткодом, на выходе файл того же типа</p></li>
<li><p><strong>llc:</strong> выполняет преобразование биткода в исходный текст на языке ассемблера для данной архитектуры. Принимает аргументы, опредеяющие уровень оптимизации</p></li>
<li><p><strong>llvm-mc:</strong> выполняет трансляцию ассемблерного кода и может создавать объектные файлы (ELF, Mach, PE). Может также дизассемблировать файлы, приводя ассемблерный код во внутренние конструкции LLVM</p></li>
<li><p><strong>lli:</strong> реализует интепретатор и JIT компилятор для IR</p></li>
<li><p><em>llvm-link:</em> выполняет компоновку нескольких файлов с биткодом в один большой файл с биткодом LLVM</p></li>
<li><p><strong>llvm-as:</strong> преобразует файлы с промежуточными представлением IR в текстовом виде (сборки LLVM), в файлы с биткодом LLVM</p></li>
<li><p><strong>llvm-dis:</strong> декодирует биткод LLVM в сборки LLVM</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id6">
<h3>Как это работает?<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// main.c</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;r = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// sum.c</span>

<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 1. можно скомпилировать все одной командой:</span>
clang main.c sum.c -o sum

<span class="c1"># 2.1 Тот же результат можно получить с помощью автономных инструментов:</span>
clang -emit-llvm -c main.c -o main.bc // получение биткод формы
clang -emit-llvm -c sum.c -o sum.bc   // или
clang -emit-llvm -S main.c -o main.ll // получение читаемой формы
clang -emit-llvm -S sum.c -o sum.ll

<span class="c1"># 2.2a Преобразовать биткод в объектные файлы, далее создать исполняемый файл путем компоновки</span>
llc -filetype<span class="o">=</span>obj main.bc -o main.o
llc -filetype<span class="o">=</span>obj sum.bc -o main.o
clang main.o sum.o -o sum

<span class="c1"># 2.2b Сначала скомпоновать файлы с биткодом в 1 файл, затем преобразовать его в объектный файл</span>
<span class="c1"># и из него получить исполняемый файл</span>
llvm-link main.bc sum.bc -o sum.linked.bc
llc -filetype<span class="o">=</span>obj sum.linked.bc -o sum.linked.o
clang sum.linked.o -o sum
</pre></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/llvm-o.png"><img alt="../../_images/llvm-o.png" src="../../_images/llvm-o.png" style="width: 600px;" /></a>
</div>
</div>
<div class="section" id="c-llvm">
<h3>Приемы программирования на C++ в LLVM<a class="headerlink" href="#c-llvm" title="Ссылка на этот заголовок">¶</a></h3>
<p>Библиотеки и инструменты LLVM написаны на языке C++ с использованием преимуществ ООП (Полиморфизма, Наследования, Инкапсуляции), а также шаблонов (template). C полным списком эффективных приемов программирования на C++, используемых в LLVM можно ознакомиться <a class="reference external" href="http://llvm.org/docs/CodingStandards.html">здесь</a></p>
</div>
<div class="section" id="id8">
<h3>Демонстрация расширяемого интерфейса проходов<a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h3>
<p>Под «проходом» в данном случае понимается анализ преобразования или оптимизации. LLVM API позволяет регистрировать собственные проходы на разных этапах компиляции. Регистрация проходов выполняются с помощью диспетчера проходов <em>PassManager</em></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">X86PassConfig</span><span class="o">::</span><span class="n">addPreEmitPass</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">getOptLevel</span><span class="p">()</span> <span class="o">!=</span> <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">None</span> <span class="o">&amp;&amp;</span> <span class="n">getX86Subtarget</span><span class="p">().</span><span class="n">hasSSE2</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">addPass</span><span class="p">(</span><span class="n">createExecutionDependencyFixPass</span><span class="p">(</span><span class="o">&amp;</span><span class="n">X86</span><span class="o">::</span><span class="n">VR128RegClass</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">getOptLevel</span><span class="p">()</span> <span class="o">!=</span> <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">None</span> <span class="o">&amp;&amp;</span>
    <span class="n">getX86Subtarget</span><span class="p">().</span><span class="n">padShortFunctions</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">addPass</span><span class="p">(</span><span class="n">createX86PadShortFunctions</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="tablegen-td">
<h3>TableGen(.td)<a class="headerlink" href="#tablegen-td" title="Ссылка на этот заголовок">¶</a></h3>
<p>Инструмент LLVM, используемый системой сборки, что бы сгенерировать программный код с++ для тех частей компилятора, которые могут быть синтезированы механическим способом</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>//DiagnosticRarseKinds.td
def err_invalid_sign_spec: Error&lt;”’%0’ cannot be signed or unsigned”&gt;<span class="p">;</span>
def err_invalid_short_spec: Error&lt;”’short %0’ is invalid”&gt;<span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Примечание</p>
<p>Цель TableGen - помочь человеку разрабатывать и поддерживать
записи информации о предметной области. Поскольку таких
записей может быть большое количество, он специально
разработан, чтобы позволить писать гибкие описания и
вычеркивать общие особенности этих записей. Это уменьшает
количество дублирования в описании, снижает вероятность
ошибки и упрощает структурирование информации, относящейся
к предметной области.
Основная часть TableGen анализирует файл, создает экземпляры
объявлений и передает результат на обработку в «бэкэнд
TableGen», зависящий от домена. В настоящее время основным
пользователем TableGen является генератор кода LLVM. В случае каких либо вопросов обращайтесь к <a class="reference external" href="https://releases.llvm.org/9.0.0/docs/TableGen/LangRef.html">документации</a></p>
</div>
</div>
</div>
<div class="section" id="id10">
<h2>Анализатор исходного кода<a class="headerlink" href="#id10" title="Ссылка на этот заголовок">¶</a></h2>
<p>Подобно названию LLVM, имеющему несколько значений, название Clang также может использоваться в трех разных смыслах:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Анализатор исходного кода</p></li>
<li><p>Драйвер компилятора</p></li>
<li><p>Фактический компилятор (clang -cc1)</p></li>
</ol>
</div></blockquote>
<p>Инструмент clang -cc1 имеет специальный параметр для вывода абстрактного синтаксического дерева (AST)</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang -Xclang -ast-dump hello.c
<span class="c1"># или</span>
clang -сс1 -ast-dump hello.c
</pre></div>
</div>
<p>Библиотеки libclang:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>linclangLex</strong>: используется для предварительной обработки и лексического анализа</p></li>
<li><p><strong>libclangAST</strong>: содержит функции для построения и управления абстрактных синтаксических деревьев</p></li>
<li><p><strong>libclangParse</strong>: используется для парсинга результатов фазы лексического анализа</p></li>
<li><p><strong>libclangSema</strong>: используется для семантического анализа</p></li>
<li><p><strong>libclangCodeGen</strong>: генерирует код промежуточного представления LLVM IR с использованием информации о целевой архитектуре</p></li>
<li><p><strong>libclangAnalysis</strong>: содержит ресурсы для статического анализа</p></li>
<li><p><strong>libclangRewrite</strong>: содержит инфраструктуру для реализации инструментов рефакторинга кода</p></li>
<li><p><strong>libclangBasic</strong>: содержит множество утилит - абстракции управлния памятью, поиск источников данных и диагностика</p></li>
</ul>
</div></blockquote>
<div class="section" id="id11">
<h3>Лексический анализ<a class="headerlink" href="#id11" title="Ссылка на этот заголовок">¶</a></h3>
<p>На самом первом этапе анализатор исходного кода разбивает языковые конструкции в текстовом формате на множество слов и лексем, удаляя такие элементы программы, как комментарии, пробелы и табуляции. Каждое слово должно принадлежать подможеству языка, а каждое зарезервированное слово преобразуется во внутреннее представление компилятора. Зарезервированные слова определены в файле <em>include/clang/Basic/TokenKinds.def</em> (Определения помещаются в пространство имён tok.т.е доступ к ним можно получить например: <strong>tok::l_brace</strong> и тд)</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// C99 6.4.2: Identifiers.</span>
<span class="n">TOK</span><span class="p">(</span><span class="n">identifier</span><span class="p">)</span> <span class="c1">// abcde123</span>
<span class="c1">// C++11 String Literals.</span>
<span class="n">TOK</span><span class="p">(</span><span class="n">utf32_string_literal</span><span class="p">)</span><span class="c1">// U&quot;foo&quot;</span>

<span class="n">PUNCTUATOR</span><span class="p">(</span><span class="n">r_paren</span><span class="p">,</span><span class="s">&quot;)&quot;</span><span class="p">)</span>
<span class="n">PUNCTUATOR</span><span class="p">(</span><span class="n">l_brace</span><span class="p">,</span><span class="s">&quot;{&quot;</span><span class="p">)</span>
<span class="n">PUNCTUATOR</span><span class="p">(</span><span class="n">less</span><span class="p">,</span> <span class="s">&quot;&lt;&quot;</span><span class="p">)</span>
<span class="n">KEYWORD</span><span class="p">(</span><span class="k">while</span><span class="p">,</span> <span class="n">KEYALL</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="clang-libtoling">
<h2>Инструменты Clang и фреймворк LibToling<a class="headerlink" href="#clang-libtoling" title="Ссылка на этот заголовок">¶</a></h2>
<p>Инструменты Clang опираются на фреймворк LibToling, библиотеку Clang, которая может служить основой для создания автономных интсрументов</p>
<p>Инструменты на базе libTooling:</p>
<blockquote>
<div><ul class="simple">
<li><p>Clang Tidy</p></li>
<li><p>Clang Modernizer</p></li>
<li><p>Clang Apply Replacements</p></li>
<li><p>ClangFormat</p></li>
<li><p>Modularize</p></li>
<li><p>PPTrace</p></li>
<li><p>Clang Query</p></li>
</ul>
</div></blockquote>
<div class="section" id="clang-tidy">
<h3>Clang-tidy<a class="headerlink" href="#clang-tidy" title="Ссылка на этот заголовок">¶</a></h3>
<p>Данный инструмент проверяет наличие в исходном коде распространенных нарушений
стандартов оформления в том числе. Инструмент просматривает дерево AST и действует намного быстрее. В отличие от средств проверки в составе статического анализатора Clang, проверки написанные для clang-tidy, обычно нацелены на определения соответствия или несоответствия определенным соглашениям по оформлению исходного кода:</p>
<blockquote>
<div><ul class="simple">
<li><p>Переносимость кода между разными компиляторами;</p></li>
<li><p>Следование определенным идиомам;</p></li>
<li><p>Возможность появления ошибок из-за злоупотребления опасными особенностями языка</p></li>
</ul>
</div></blockquote>
<p>Проверка исходного кода с помощью Clang-tidy:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang-tidy <span class="o">[</span>параметры<span class="o">]</span> <span class="o">[</span>&lt;файл0&gt;..&lt;файлN&gt;<span class="o">]</span> <span class="o">[</span>--команды компилятора<span class="o">]</span>
<span class="c1"># можно воспользоваться * в параметре -checks для запуска множества проверок</span>
clang-tidy -checks<span class="o">=</span><span class="s2">&quot;llvm-*&quot;</span> file.cpp
</pre></div>
</div>
<p>Так как наш код компилируется вместе с Clang, нам потребуется база данных команды компиляции. Поэтому начнем с её создания. Перейдите в каталог, где находятся исходные тексты LLVM, и создайте отдельный каталог для хранения файлов CMake</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir cmake-scripts
<span class="nb">cd</span> cmake-scripts
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS<span class="o">=</span>ON ../llvm
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Совет</p>
<p>Если вы столкнетесь с ошибкой, сообщающей о неизвестном исходном файле и          ссылающейся на файл с реализацией нашего средства проверки, созданный в прерыдущей главе, просто добавьте имя этого файла в <em>CMakeLists.txt</em>. Для этого выполните следующую команду и запустите CMake еще раз</p>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>vim ../llvm/tools/clang/lib/StaticAnalyzer/Checkers/CMakeLists.txt
</pre></div>
</div>
<p>Затем в корневом каталоге LLVM создайте ссылку на файл базы данных команд компиляции</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ln -s <span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/compile_commands.json ../llvm
<span class="c1"># Теперь можно вызвать сам инструмент</span>
<span class="nb">cd</span> ../llvm/tools/clang/lib/StaticAnalyzer/Checkers
clang-tidy -checks<span class="o">=</span><span class="s2">&quot;llvm-*&quot;</span> ReactorChecker.cpp
</pre></div>
</div>
<p>Пример по использованию clang-tidy:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang-tidy test.cpp --fix-errors --fix
-checks<span class="o">=</span>bugprone-*,cppcoreguidelines-*,misc-*,modernize-*,performance-*,readability-* --
</pre></div>
</div>
<p>Было:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
int main<span class="o">()</span> <span class="o">{</span>
  int i<span class="p">;</span>
  <span class="nb">printf</span> <span class="o">(</span>“%d”, i<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Стало:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="k">auto</span> <span class="nf">main</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="clang-modernizer">
<h3>Clang Modernizer<a class="headerlink" href="#clang-modernizer" title="Ссылка на этот заголовок">¶</a></h3>
<p><strong>Clang Modernizer</strong> = это революционный инструмент, цель которого помочь польщователям адаптировать старый код на С++ под новейшие стандарты:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>преобразование циклов:</strong> циклы в старом С for (;;), преобразуются в более новые циклы вида: for (auto &amp;…:..)</p></li>
<li><p><strong>преобразование пустых указателей:</strong> константы NULL и 0, используемые для представления пустых указателей, замещаются nullptr (C++11)</p></li>
<li><p><strong>преобразование с добавлением ключевого слова auto:</strong> в некоторые объявляения включается ключевое слово <em>auto</em> для повышения читаемости кода</p></li>
<li><p><strong>преобразование с добавлением ключевого слова override:</strong> добавляет в объявление методов, переопределяющих виртуальные методы родительских классов, спецификатор override</p></li>
<li><p><strong>преобразование передачи аргументов по значению:</strong> передача константных ссылок замещается передачей по значени с выполнением операции копирования</p></li>
<li><p><strong>преобразование с заменой auto_ptr:</strong> замещает старые автоматические указатели std::auto_ptr на std::unique_ptr</p></li>
</ul>
</div></blockquote>
<p>Пример по использованию clang-modernizer:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang-modernize <span class="o">[</span>параметры<span class="o">]</span> &lt;файл0&gt; <span class="o">[</span>... &lt;файлN&gt;<span class="o">]</span> <span class="o">[</span>--&lt;команда компилятора&gt;<span class="o">]</span>
</pre></div>
</div>
</div>
<div class="section" id="clang-apply-replacements">
<h3>Clang Apply Replacements<a class="headerlink" href="#clang-apply-replacements" title="Ссылка на этот заголовок">¶</a></h3>
<p>Данный интструмент отвечает за чтение файлов с поправками (Clang Modernize), отсеивает протиречивые и повторяющиеся поправки, и применяет их к файлам с исходными текстами.</p>
<p>Пример запуска:</p>
<ul class="simple">
<li><p>Чтобы опробовать Clang Apply Replacements нам нужно сначало воспользоваться Clang Modernizer и сохранить его поправки в файл</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Согласно руководству к Clang-Modernize, этот цикл можно безопасно преобразовать в цикл с помощью auto. Для этого следует выполнить:</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang-modernize -loop-convert -serialize-replacements test.cpp --serialize-dir<span class="o">=</span>./
</pre></div>
</div>
<ul class="simple">
<li><p>Чтобы применить исправления, надо выполнить команду:</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang-apply-replacements
</pre></div>
</div>
</div>
<div class="section" id="clangformat">
<h3>ClangFormat<a class="headerlink" href="#clangformat" title="Ссылка на этот заголовок">¶</a></h3>
<p>Реализация форматирования кода в соответствии с соглашениями Инструмент, позволяющий разбить код на 80-символьные строки и улучшить его удобочитаемость.</p>
<p>Пример запуска:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// test.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span>
<span class="n">i</span><span class="p">);</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span>
<span class="n">i</span><span class="p">);</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Запускаем команду:</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># clang-format -style=LLVM -dump-config &gt; .clang-format</span>
clang-format --style-LLVM test.cpp
</pre></div>
</div>
<ul class="simple">
<li><p>Результат:</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="modularize">
<h3>Modularize<a class="headerlink" href="#modularize" title="Ссылка на этот заголовок">¶</a></h3>
<p>Целью этого инструмента является оказание помощи в решении задачи внедрения модулей. Он анализирует множество заголовочных файлов и сообщает, если обнаруживает повторяющиеся определения переменных, макросов или определения макросов, которые могут приводить к разным результатам</p>
<p>Пример запуска:</p>
<ul class="simple">
<li><p>Создадим файл list.txt:</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>gamelogic.h
screenlogic.h
</pre></div>
</div>
<ul class="simple">
<li><p>Теперь достаточно запустить modularize и передвать ему файл:</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>modularize list.txt
</pre></div>
</div>
<ul class="simple">
<li><p>Если изменить один из заголовочных файлов, включив в него символы из другого заголовочного файла, modularize сообщит, что проект опирается на небезопасное для модулей поведение, и что следует исправить проблему перед повторной попыткой создать файл module.modulemap</p></li>
</ul>
</div>
<div class="section" id="module-map-checker">
<h3>Module Map Checker<a class="headerlink" href="#module-map-checker" title="Ссылка на этот заголовок">¶</a></h3>
<p>Инструмент исследует файл module.modulemap, проверяя - охватывае ли он все заголовочные файлы в каталоге</p>
<ul class="simple">
<li><p>Пример запуска:</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>module-map-checker module.modulemap
</pre></div>
</div>
</div>
<div class="section" id="pptrace">
<h3>PPTrace<a class="headerlink" href="#pptrace" title="Ссылка на этот заголовок">¶</a></h3>
<blockquote class="epigraph">
<div><p>«Танцует в тесном контакте с лекическим аназизатором, чтобы обеспечивать эффективнуб предварительную обработку лексем»</p>
</div></blockquote>
<p>Вывод трассировочной информации о работе препроцессора. Достигается это за счет реализации функций обратного вызова в интерфейсе clang::PPCallbacks</p>
<p>Он начинает с регистрации самого себя в роли «наблюдателя» за препроцессором и затем запускает анализ файлов. Информация о всех действиях препроцессора, таких как интерпретация директивы #if, импортирование модуля, подключение заголовочного файла и многих других, выводится на экран</p>
<p>Пример запуска:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// hello.cpp</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#include</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CAPITALIZE</span>
<span class="cp">#define WORLD &quot;WORLD&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define WORLD &quot;world&quot;</span>
<span class="cp">#endif</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">write</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span>
<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Hello, &quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
  <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">WORLD</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Запускаем инструмент:</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pp-trace hello.c
</pre></div>
</div>
<ul class="simple">
<li><p>В результате возникает серия событий препроцессора, касающихся определния макросов, еще до того, как начнется фактическая обработка исходного файла:</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-Callback: <span class="k">if</span>
 Loc: <span class="s2">&quot;hello.c:1:2&quot;</span>
 ConditionRange: <span class="o">[</span>:<span class="s2">&quot;hello.c:1:4&quot;</span>, <span class="s2">&quot;hello.c:2:1&quot;</span><span class="o">]</span>
 CondiotionValue: CVK_False
 ..
</pre></div>
</div>
</div>
<div class="section" id="clang-query">
<h3>Clang-Query<a class="headerlink" href="#clang-query" title="Ссылка на этот заголовок">¶</a></h3>
<p>Дает возможность исследовать дерево AST программы и отыскивать его сегменты по заданным условиям. Читает исходные файлы и интерактивно запрашивать узлы дерева AST. Выявляет узлы AST, соответствующие заданным условиям. Список доступных предикатов можно найти в заголовочном файле ASTMatchers.h.
Предполагает наличие базы данных команд компиляции.</p>
<p>Пример запуска:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang-query hello.c --
</pre></div>
</div>
<ul class="simple">
<li><p>После запука, инструмент выведет интерактивное приглашение к вводу, ожидая команд. Теперь можно вести команду match и имя предиката. Например, следующая команда требует от clang-query вывести все узлы типа CallExpr:</p></li>
</ul>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang-query&gt; match callExpr<span class="o">()</span>

Match <span class="c1">#1</span>
hello.c:12:5: note: <span class="s2">&quot;root&quot;</span> node binds here
  write<span class="o">(</span><span class="m">1</span>, <span class="s2">&quot;Hello, &quot;</span>, <span class="m">7</span><span class="o">)</span><span class="p">;</span>
  ^~~~~~~~~~~~~~~~~~~~~~~
</pre></div>
</div>
<p>Cписок команд:</p>
<ul class="simple">
<li><p>help: выводит список доступных команд;</p></li>
<li><p>match &lt;имя предиката&gt; или m &lt;имя предиката&gt;: выполняет обход дерева AST и выполняет поиск узлов, соответствующих указанному предикату;</p></li>
<li><dl class="simple">
<dt>set output &lt;(diag | print | dump)&gt;: определяет, как будет выводиться информация о найденных узлах</dt><dd><ul>
<li><p>Параметр diag (действует по умолчанию) обеспечивает вывод диагностических сообщений для найденных узлов.</p></li>
<li><p>Параметр print обеспечивает простой вывод соответствующего фрагмента исходного кода.</p></li>
<li><p>Параметр dump обеспечивает вызов метода dump(),который дополнительно выводит все дочерние узлы</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="clang-check">
<h3>Clang-Check<a class="headerlink" href="#clang-check" title="Ссылка на этот заголовок">¶</a></h3>
<p>Clang-Check позволяет выполнять парсинг исходного кода на C/C++ и выводить дерево AST или выполнять простые проверки. Он также может применять «исправления», предлагаемые Clang, используя инфраструктуру, построенную на основе Clang Modernizer</p>
<p>Чтобы получить дерево AST для файла:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang-check &lt;Имя_файла&gt; -ast-dump --
</pre></div>
</div>
</div>
<div class="section" id="c-str">
<h3>Удаление вызовов c_str() «Самый маленький инструмент для рефакторинга»<a class="headerlink" href="#c-str" title="Ссылка на этот заголовок">¶</a></h3>
<p>Инструмент <em>remove-cstr-calls</em>  - это просто пример инструмента преобразование исходных текстов, то есть, инструмента рефакторинга. Он ищет избыточные вызовы метода c_str() обьектов str::string и удаляет их.</p>
<p>Такие вызовы считаются избыточными когда:</p>
<ul class="simple">
<li><p>когда новый объект string создается с вызовом метода c_str() другого объекта string. Например <strong>std::string(myString.c_str())</strong>. Эту операцию можно упростить за счет использования конструктора копии: <strong>std::string(myString)</strong></p></li>
<li><p>когда на основе объектов string создаются новые экземпляры классов LLVM StringRef и Twine. В этих случаях предпочтительнее использовать сам обьект string, а не результат вызова c_str(), то есть: <strong>StringRef(myString)</strong> вместо <strong>StringRef(myString).c_str()</strong></p></li>
</ul>
</div>
</div>
<div class="section" id="libclang">
<h2>Создание собственного инструмента (libclang)<a class="headerlink" href="#libclang" title="Ссылка на этот заголовок">¶</a></h2>
<p>Проект Clang предоставляет 3 интерфейса для доступа к функциональным возможностям Clang:</p>
<ul class="simple">
<li><p><strong>libclang:</strong> является основным интерфейсом к механизмам Clang. Поддерживает обратную совместимость, обеспечивая работоспособность существующего ПО после выхода новой версии <em>libclang</em></p></li>
<li><p><strong>Clang Plugins:</strong> позволяет добавлять свои проходы непосредственно в процедуру компиляции</p></li>
<li><p><strong>LibTooling</strong> позволяет создавать самостоятельные инструменты, предназначенные для выполнения рефакторинга кода или проверки синтаксиса. В отличии от libclang менее надежен с точки зрения поддержки обратной совместимости, но зато дает полный доступ к структуре дерева AST</p></li>
</ul>
<p>Пример создание инструмента:</p>
<ol class="arabic simple">
<li><p>Найдите каталог <em>llvm-project/clang-tools-extra/</em>. Там лежит <em>tool-template</em>. В нём Cmake и код. Для написания собственного инструмента достаточно написать код на cpp и изменить имя в Cmake. Tool должен лежать тоже в этом каталоге</p></li>
<li><p>Назовем наш инструмент <em>cxxgrep</em>, он будет способен различать конструкции языка <em>C++</em>. Пример опций:</p></li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>-function  <span class="c1"># Filter by functions</span>
-i         <span class="c1"># Make the search case-insensitive</span>
-member    <span class="c1"># Filter by members</span>
-parameter <span class="c1"># Filter by function parameter</span>
-record    <span class="c1"># Filter by records (class/struct)</span>
-variable  <span class="c1"># Filter by variables</span>
</pre></div>
</div>
</div>
<div class="section" id="llvm-ir">
<h2>LLVM IR<a class="headerlink" href="#llvm-ir" title="Ссылка на этот заголовок">¶</a></h2>
<p><strong>LLVM IR</strong> - промежуточное представление, магистраль связываюшая анализаторы исходного кода и генераторы выполняемого кода, которая позволяет LLVM анализировать програму на разных языках программирования и генерировать код для разных целевых архитектур</p>
<dl class="simple">
<dt><strong>SSA (Single Static Assignments)</strong></dt><dd><ul class="simple">
<li><p>трехадресные инструкции</p></li>
<li><p>бесконечное множество регистров</p></li>
</ul>
</dd>
</dl>
<p>Имея общее промежуточное представление, можно реализовать комплекс оптимизаций, независимо от поддерживаемых архитектур, но это требует поднять уровень IR</p>
<p>Промежуточное представление IR имеет три эквивалентные формы:</p>
<blockquote>
<div><ul class="simple">
<li><p>представление в памяти (класс <em>Instruction</em>)</p></li>
<li><p>представление на диске в файле <strong>биткода</strong></p></li>
<li><p>представление на диске в удобочитаемом <strong>текстовом формате</strong></p></li>
</ul>
</div></blockquote>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang name.c -emit-llvm -c -o name.bc <span class="c1">#Генерация биткода файла</span>

clang name.c -emit-llvm -S -c -o name.ll <span class="c1">#Генерация читаемого представления LLVM IR</span>

llvm-as name.ll -o name.bc <span class="c1">#Сборку преобразовать в бит-код</span>

llvm-dis name.bc -o name.ll <span class="c1">#бит-код в сборку</span>

llvm-extract -func<span class="o">=</span>sum sum.bc -o sum-fn.bc <span class="c1">#Извлечь функцию sum из файла sum.bc</span>
</pre></div>
</div>
<p>C/C++ имеют врожденную зависимость от платформы, при подключении заголовочных файлов, неявно подключаются файлы из каталога bits, который является собственным для каждой архитектуры. Если программа использует стандартные заголовочные файлы то уже на этапе AST мы зависим от архитектуры, что усложняет написание независимого IR</p>
<div class="section" id="ll">
<h3>Содержание .ll файла<a class="headerlink" href="#ll" title="Ссылка на этот заголовок">¶</a></h3>
<p>Подготовим .ll файл</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">clang</span> <span class="o">-</span><span class="n">c</span> <span class="n">example</span><span class="p">.</span><span class="n">cpp</span>  <span class="o">-</span><span class="n">O0</span> <span class="o">--</span><span class="n">target</span><span class="o">=</span><span class="n">xcore</span> <span class="o">-</span><span class="n">emit</span><span class="o">-</span><span class="n">llvm</span> <span class="o">-</span><span class="n">S</span> <span class="o">-</span><span class="n">o</span> <span class="n">add_o0</span><span class="p">.</span><span class="n">ll</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;example.cpp&#39;</span>
<span class="nv">source_filename</span> <span class="o">=</span> <span class="s2">&quot;example.cpp&quot;</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-m:e-p:32:32-i1:8:32-i8:8:32-i16:16:32-i64:32-f64:32-a:0:32-n32&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;xcore&quot;</span>

<span class="p">;</span> Function Attrs: noinline nounwind optnone
define dso_local i32 @_Z3sumii<span class="o">(</span>i32 %a, i32 %b<span class="o">)</span> <span class="c1">#0 {</span>
entry:
  %a.addr <span class="o">=</span> alloca i32, align <span class="m">4</span>
  %b.addr <span class="o">=</span> alloca i32, align <span class="m">4</span>
  store i32 %a, i32* %a.addr, align <span class="m">4</span>
  store i32 %b, i32* %b.addr, align <span class="m">4</span>
  %0 <span class="o">=</span> load i32, i32* %a.addr, align <span class="m">4</span>
  %1 <span class="o">=</span> load i32, i32* %b.addr, align <span class="m">4</span>
  %add <span class="o">=</span> add nsw i32 %0, %1
  ret i32 %add
<span class="o">}</span>

attributes <span class="c1">#0 = { noinline nounwind optnone &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;frame-pointer&quot;=&quot;none&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;min-legal-vector-width&quot;=&quot;0&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-jump-tables&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; }</span>

!llvm.module.flags <span class="o">=</span> !<span class="o">{</span>!0<span class="o">}</span>
!llvm.ident <span class="o">=</span> !<span class="o">{</span>!1<span class="o">}</span>

!0 <span class="o">=</span> !<span class="o">{</span>i32 <span class="m">1</span>, !<span class="s2">&quot;wchar_size&quot;</span>, i32 <span class="m">1</span><span class="o">}</span>
!1 <span class="o">=</span> !<span class="o">{</span>!<span class="s2">&quot;clang version 10.0.1 (https://github.com/llvm/llvm-project.git ef32c611aa214dea855364efd7ba451ec5ec3f74)&quot;</span><span class="o">}</span>
</pre></div>
</div>
<p>Для примера было выбрано ядро процессора xcore, так как он не имеет каких-либо сложных особенностей при компиляции в IR-код, поэтому является идеальным объектом для исследований. Это ядро имеет разрядность 32, и clang выравнивает все переменные по границам 32-битных слов</p>
<p>Модуль - это структура данных LLVM IR верхнего уровня. Каждый модуль содержит последовательность функций, каждая из которых состоит из группы базовых блоков, которые в свою очередь содержат последовательности инструкций. Модуль также включает глобальные переменные, определение формата данных, прототипы внешних функций объявление структур данных</p>
<dl class="simple">
<dt><strong>Модуль:</strong></dt><dd><ul class="simple">
<li><p>Глобальные переменные/определение функций</p></li>
<li><dl class="simple">
<dt>Функции</dt><dd><ul>
<li><dl class="simple">
<dt>Базовые блоки</dt><dd><ul>
<li><p>Инструкции</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p>Атрибуты</p></li>
</ul>
</dd>
</dl>
<p>Локальные значения LLVM являются аналогами регистров в языке ассемблера и могут иметь любые имена, начинающиеся с символа %. Инструкция складывает локальные значения %0 и %1, и сохраняет результат в %add</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>%add <span class="o">=</span> add nsw i32 %0, %1
</pre></div>
</div>
<p>Конструкция <em>target datalayout</em> содержит информацию о порядке следования байтов (endianness) и размерах типов для триады <em>target triple</em>, описывающей целевой хост. Некоторые виды оптимизации зависят от формата данных.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;example.cpp&#39;</span> <span class="c1"># название модуля</span>
<span class="nv">source_filename</span> <span class="o">=</span> <span class="s2">&quot;example.cpp&quot;</span> <span class="c1"># путь к файлу</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-m:e-p:32:32-i1:8:32-i8:8:32-i16:16:32-i64:32-f64:32-a:0:32-n32&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;xcore&quot;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Целевой платформой является <strong>xcore</strong>. Данные в памяти хранятся в формате little-endian (e). На архитектурах с big-endian первой будет следовать буева (E)</p></li>
<li><p>Информация о типах имеет формат: <em>type: &lt;size&gt; : &lt;abi&gt; : &lt;preferred&gt;</em>. Определение <strong>p:32:32</strong> в предыдущем примере представляет указатель, имеющий размер 32 бита, <em>abi</em> указыват на минимально необходимое выравнивание для типа, <em>preferred</em> - наибольшее возможное выравнивание.</p></li>
</ul>
</div>
<div class="section" id="id12">
<h3>Определение функций в .ll<a class="headerlink" href="#id12" title="Ссылка на этот заголовок">¶</a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>define i32 @sum <span class="o">(</span>i32 %a, i32 %b<span class="o">)</span> <span class="o">{</span> <span class="c1"># упрощенная форма</span>
define dso_local i32 @_Z3sumii<span class="o">(</span>i32 %a, i32 %b<span class="o">)</span> <span class="c1">#0 { # сгенерированая форма из примера</span>
</pre></div>
</div>
<p>Эта функция возвращает значения типа i32 и принимает два аргумента типа i32, %a и %b. <strong>Локальные идентификаторы всегда должны начинаться с символа %</strong>, а <strong>глобальные - с символа &#64;</strong></p>
<dl class="simple">
<dt>Наиболее важные типы данных:</dt><dd><ul class="simple">
<li><p>целые числа произвольного размера в форме <em>iN</em> (i32, i64)</p></li>
<li><p>вещественные числа, <em>float</em> 32-разрядные одинарной точности, <em>double</em> 64-разрядные двойной точности</p></li>
<li><p>векторные типы, определения которых имеет вид: &lt;n_elements x elements_type&gt;. Тип соответсвующий вектору с четырьмя элементами типа i32 определяется как &lt;4 x i32&gt;</p></li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="id13">
<h3>Атрибуты<a class="headerlink" href="#id13" title="Ссылка на этот заголовок">¶</a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>attributes <span class="c1">#0 = { noinline nounwind optnone &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot;</span>
<span class="s2">&quot;disable-tail-calls&quot;</span><span class="o">=</span><span class="s2">&quot;false&quot;</span> <span class="s2">&quot;frame-pointer&quot;</span><span class="o">=</span><span class="s2">&quot;none&quot;</span> <span class="s2">&quot;less-precise-fpmad&quot;</span><span class="o">=</span><span class="s2">&quot;false&quot;</span> <span class="s2">&quot;min-legal-vector-width&quot;</span><span class="o">=</span><span class="s2">&quot;0&quot;</span>
<span class="s2">&quot;no-infs-fp-math&quot;</span><span class="o">=</span><span class="s2">&quot;false&quot;</span> <span class="s2">&quot;no-jump-tables&quot;</span><span class="o">=</span><span class="s2">&quot;false&quot;</span> <span class="s2">&quot;no-nans-fp-math&quot;</span><span class="o">=</span><span class="s2">&quot;false&quot;</span> <span class="s2">&quot;no-signed-zeros-fp-math&quot;</span><span class="o">=</span><span class="s2">&quot;false&quot;</span>
<span class="s2">&quot;no-trapping-math&quot;</span><span class="o">=</span><span class="s2">&quot;false&quot;</span> <span class="s2">&quot;stack-protector-buffer-size&quot;</span><span class="o">=</span><span class="s2">&quot;8&quot;</span> <span class="s2">&quot;unsafe-fp-math&quot;</span><span class="o">=</span><span class="s2">&quot;false&quot;</span> <span class="s2">&quot;use-soft-float&quot;</span><span class="o">=</span><span class="s2">&quot;false&quot;</span> <span class="o">}</span>
</pre></div>
</div>
<p>Тег <em>#0</em> в определении функции отображается в множество атрибутов функции. Множество атрибутов определяется в конце файла</p>
<blockquote>
<div><ul class="simple">
<li><p>noinline - функция которая не встраивается</p></li>
<li><p>nounwind - функции которые не порождают исключений</p></li>
<li><p>uwtable - требование раскрутки циклов</p></li>
<li><p>optnone - большинство проходов оптимизаций пропускают эту функцию</p></li>
<li><p><a class="reference external" href="https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a> - можно помотреть множество аттрибутов</p></li>
</ul>
</div></blockquote>
<p>Тело функции явно разделено на <strong>базовые блоки(Basic Blocks, BB)</strong> и каждый новый блок начинается с метки. Метка связана с базовым блоком, точно так же, как и идентификатор значения инструкции. Если метка опущена, ассемблер LLVM сгенерирует её, опираясь на собственные соглашения  об именовании
Базовый блок - это последовательность инструкций с единственной точкой входа в первой инструкции и единственной точйно выхода в последней инструкции. То есть, когда код выполняет переход к метке, соответсвующей базовому блоку, можно быть уверенными, что будут выполнены все инструкции в этом блоке, от первой до последней, причем последняя инструкция направит поток выполнения к другому блоку. Базовые блоки и соответсвующие им метки должны соответствовать условиям:</p>
<blockquote>
<div><ul class="simple">
<li><p>каждый базовый блок должен завершаться инструкцией, выполняющей переход к следующему базовому блоку или возврат из функции</p></li>
<li><p>первый базовый блок, который еще называют блоком вхожа - играет особую роль в функциях LLVM и не должен использоваться как цель</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id14">
<h3>Инструкции<a class="headerlink" href="#id14" title="Ссылка на этот заголовок">¶</a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="nl">entry</span><span class="p">:</span>
    <span class="o">%</span><span class="n">a</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">alloca</span> <span class="n">i32</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
    <span class="o">%</span><span class="n">b</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">alloca</span> <span class="n">i32</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
    <span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
    <span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
    <span class="o">%</span><span class="mi">0</span> <span class="o">=</span> <span class="n">load</span> <span class="n">i32</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
    <span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="n">load</span> <span class="n">i32</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">align</span> <span class="mi">4</span>
    <span class="o">%</span><span class="n">add</span> <span class="o">=</span> <span class="n">add</span> <span class="n">nsw</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="mi">1</span>
    <span class="n">ret</span> <span class="n">i32</span> <span class="o">%</span><span class="n">add</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Инструкция <strong>alloca</strong> резервирует пространство в кадре стека текущей функции. Обьем пространства определяется размером типа элемента с учетом указанного выравнивания. Первая инструкция * %a.addr = alloca i32, align 4*, выделяет место на стеке для 4-байтного элемента с выравниванием по границе 4 байт. Указатель на элемент в стеке сохраняется в локальном идентификаторе <em>%a.addr</em></p></li>
<li><p>Аргументы %a и %b сохраняются на стеке, по адресам %a.addr и %b.addr с помощью инструкии <strong>store</strong></p></li>
<li><p>Загрузка значений выполняется инструкциями <strong>load</strong></p></li>
<li><p>Эти значения используются в операции сложения <em>%add = add nsw i32 %0, %1</em>. И результат функции add, возвращается из функции <strong>ret</strong>. Флаг <em>nsw</em> указывает, что данная операция сложения не должна проверять перенос в знаковый бит (no signed wrap)</p></li>
<li><p>Инструкции <em>load</em> и <em>store</em> являются избыточными - аргументы функции можно использовать в инструкции <em>add</em> непосредственно. Сlang использует по умолчанию уровень оптимизации -O0, поэтому избыточные инструкции не удаляться. А если скомпилировать с -O1, на выходе получится более простой код:</p></li>
</ul>
<p>Пример файла с циклом:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>define i32 @sum<span class="o">(</span>i32 %a, i32 %b<span class="o">)</span> <span class="o">{</span>
entry:
  %add <span class="o">=</span> add nsw i32 %b, %a
  ret i32 %add
<span class="o">}</span>
</pre></div>
</div>
<p>Пример файла с циклом:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">for_loop</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>clang -c example.cpp  -O0 --target<span class="o">=</span>xcore -emit-llvm -S -o add_o0.ll
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;example.cpp&#39;</span>
<span class="nv">source_filename</span> <span class="o">=</span> <span class="s2">&quot;example.cpp&quot;</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-m:e-p:32:32-i1:8:32-i8:8:32-i16:16:32-i64:32-f64:32-a:0:32-n32&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;xcore&quot;</span>

<span class="p">;</span> Function Attrs: noinline nounwind optnone
define dso_local i32 @_Z8for_loopPi<span class="o">(</span>i32* %x<span class="o">)</span> <span class="c1">#0 {</span>
entry:
  %x.addr <span class="o">=</span> alloca i32*, align <span class="m">4</span>
  %sum <span class="o">=</span> alloca i32, align <span class="m">4</span>
  %i <span class="o">=</span> alloca i32, align <span class="m">4</span>
  store i32* %x, i32** %x.addr, align <span class="m">4</span>
  store i32 <span class="m">0</span>, i32* %sum, align <span class="m">4</span>
  store i32 <span class="m">0</span>, i32* %i, align <span class="m">4</span>
  br label %for.cond

<span class="k">for</span>.cond:                                         <span class="p">;</span> <span class="nv">preds</span> <span class="o">=</span> %for.inc, %entry
  %0 <span class="o">=</span> load i32, i32* %i, align <span class="m">4</span>
  %cmp <span class="o">=</span> icmp slt i32 %0, <span class="m">10</span>
  br i1 %cmp, label %for.body, label %for.end

<span class="k">for</span>.body:                                    <span class="p">;</span> <span class="nv">preds</span> <span class="o">=</span> %for.cond
  %1 <span class="o">=</span> load i32*, i32** %x.addr, align <span class="m">4</span>
  %2 <span class="o">=</span> load i32, i32* %i, align <span class="m">4</span>
  %arrayidx <span class="o">=</span> getelementptr inbounds i32, i32* %1, i32 %2
  %3 <span class="o">=</span> load i32, i32* %arrayidx, align <span class="m">4</span>
  %4 <span class="o">=</span> load i32, i32* %sum, align <span class="m">4</span>
  %add <span class="o">=</span> add nsw i32 %4, %3
  store i32 %add, i32* %sum, align <span class="m">4</span>
  br label %for.inc

<span class="k">for</span>.inc:                                   <span class="p">;</span> <span class="nv">preds</span> <span class="o">=</span> %for.body
  %5 <span class="o">=</span> load i32, i32* %i, align <span class="m">4</span>
  %inc <span class="o">=</span> add nsw i32 %5, <span class="m">1</span>
  store i32 %inc, i32* %i, align <span class="m">4</span>
  br label %for.cond

<span class="k">for</span>.end:                                   <span class="p">;</span> <span class="nv">preds</span> <span class="o">=</span> %for.cond
  %6 <span class="o">=</span> load i32, i32* %sum, align <span class="m">4</span>
  ret i32 %6
<span class="o">}</span>

attributes <span class="c1">#0 = { noinline nounwind optnone ... }</span>

!llvm.module.flags <span class="o">=</span> !<span class="o">{</span>!0<span class="o">}</span>
!llvm.ident <span class="o">=</span> !<span class="o">{</span>!1<span class="o">}</span>

!0 <span class="o">=</span> !<span class="o">{</span>i32 <span class="m">1</span>, !<span class="s2">&quot;wchar_size&quot;</span>, i32 <span class="m">1</span><span class="o">}</span>
!1 <span class="o">=</span> !<span class="o">{</span>!<span class="s2">&quot;clang version 10.0.1 (https://github.com/llvm/llvm-project.git ef32c611aa214dea855364efd7ba451ec5ec3f74)&quot;</span><span class="o">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>Финода</strong>- конструкция для определения значения переменной в зависимости от какого-то условия. В контексте SSA в зависимости от блока из которого мы пришли. <em>phi i32 [ 0, %0 ], [ %5, %1 ]</em>. Это означает, что функция примет значение 0, если переход произошёл с базового блока %0 (первый базовый блок в функции), и значение переменной %5, если переход произошёл с базового блока %1 (т.е. с выходной точки этого же базового блока)</p></li>
</ul>
</div>
</div>
<div class="section" id="id15">
<h2>Оптимизации времени компиляции и времени компоновки<a class="headerlink" href="#id15" title="Ссылка на этот заголовок">¶</a></h2>
<p>Clang и Opt: -O0, -O1, -O2, -O3, -Os, -Oz</p>
<p>Дополнительный уровень оптимизации Clang -O4</p>
<ul class="simple">
<li><p>-O4 - влаг оптимизаций типа -O3 с дополнительным флагом -flto (оптимизации времени компоновки)</p></li>
<li><p>-Ox - определяет уровень оптимизаций</p></li>
<li><p>-O0 - отсутствие оптимизаций</p></li>
<li><p>-Os и -Oz - Такие же как и -O2 с дополнительными оптимизациями для уменьшения объема выполняемого кода</p></li>
<li><p>-O2 - уровень умеренной оптимизации, включает в себя большинство из доступных</p></li>
<li><p>-O3 - Такой же как -O2, дополнительно включающий оптимизации на которые требуется больше времени или которые приводят к увеличению объема кода.</p></li>
</ul>
</div>
<div class="section" id="id16">
<h2>Используемая литература<a class="headerlink" href="#id16" title="Ссылка на этот заголовок">¶</a></h2>
<p><a class="reference external" href="LLVMbook.pdf">LLVM. Инфраструктура для разработки компиляторов</a></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Авторские права 2020, Bulatov Alexandr

    </p>
  </div>
    
    
    
    Собрано при помощи <a href="http://sphinx-doc.org/">Sphinx</a> с использованием
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">темы,</a>
    
    предоставленной <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>