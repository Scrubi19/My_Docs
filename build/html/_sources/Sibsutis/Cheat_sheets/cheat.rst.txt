Шпаргалки
==============

Git
~~~~~~~~~~~~~~~

Создание репозитория
""""""""""""""""""""""

Начнем с самого начала, а именно с создания репозитория. Создать репозиторий можно двумя способами:

#. "Ленивый". Создаем пустой репозиторий на сайте github.com, bitbucket.org и клонируем его командой например:

.. code-block:: bash
  
  git clone https://github.com/Scrubi19/My_Docs.git

#. Этот способ заключается в первоначальном создании локального репозитория у вас на машине, а потом локальный репозиторий размещается на одном из выбранном вами ресурсе (github,bitbucket)

.. code-block:: bash

  # создаем репозиторий локально
  git init
  git add .
  git commit -m "initial commit"

  # создаем репозиторий на github через API
  curl -u 'USER_NAME' https://api.github.com/user/repos -d'{"name":"NAME_REPOSITORY"}'
  git remote add origin https://github.com/'USER_NAME'/'NAME_REPOSITORY'.git
  git push origin master

Команды
""""""""""

.. code-block:: bash
  
  # Основы
  git status # cписок всех измененных и добавленных файлов 
  git add file.txt # добавление файла/папки для коммита
  git add . # добавление всех файлов для коммита
  git commit -m "name of commit" # выполнение коммита файлов
  git push origin master # передача коммита на удаленный сервер
  git pull origin master # вливание текущей ветки и указанной ветки (обновление ветки с удаленного сервера)
  git branch # список всех веток (текущая помечена *)
  git log # просмотр логов коммитов
  git blame README.md # построчная информация о последнем коммите
  git reset --hard 9a452d955bdb57e7e4f2b09f8ce2fbb6cd56377a # откат на коммит


  #checkout
  git checkout -b new_branch # создание новой ветки
  git checkout new_branch # переход на новую ветку
  git checkout deleted_file.txt # восстановление удаленного файла


  #merge
  git checkout master
  git merge dev #  выполняет слияние текущей и указанной ветки


  # конфликт сливаемых бинарных файлов
  git checkout --ours binary.dat # выбираем файл для коммита из нашей ветки
  git checkout --theirs binary.dat # выбираем файло для коммита из вливаемой ветки


  # cherry-pick помогает применить один-единственный коммит из одной ветки к дереву другой
  git checkout master
  git cherry-pick eb042098a5 # коммит другой ветки
  git push origin master


  # настройка вывода дерева коммитов
  git config --global alias.hist "log --oneline --decorate --graph --all"

   
  git mergetool # инструмент для решения конфликтов

  # Удаление игнорируемых файлов
  git rm --cached <file>

Памятка по .gitignore
""""""""""""""""""""""

.. code-block:: bash

  # Игнор-лист файлов проекта
  # Игнорировать ВСЕ файлы и директории, включая поддиректории и файлы в них
  *
  # ---- ФАЙЛЫ ----
  # Игнорирование по типу файла, будут игнорироваться в АБСОЛЮТНО всех     директориях
  # Например /files/data.zip, /server.log, /uploads/users/data/info.xls
  *.zip
  *.log
  *.pdf
  *.xls
  # Игнорирование файла во ВСЕХ директориях
  # Например /params/db/config.php, /config.php
  config.php
  # Игнорирование конкретного файла ТОЛЬКО в корне проекта
  # (корнём считается расположение файла .gitignore)
  # Например НЕ БУДЕТ проигнорирован файл /db/config.php
  /config.php
  # Игнорирование конкретного файла ТОЛЬКО в указанной директории
  # Например НЕ БУДЕТ проигнорирован файл /prod/params/config.php
  /params/config.php
  # ---- ДИРЕКТОРИИ ----
  # Игнорирование всех файлов и папок ТОЛЬКО в конкретной директории(включая   поддиректории и файлы в них)
  # Например /images/user.jpg, /images/company/logo.png
  # НЕ БУДУТ проигнорированы файлы и папки /prod/images/user.jpg
  /images/*
  # Игнорирование всех файлов и папок в ЛЮБЫХ директориях с указанным именем
  # Например /images/user.jpg, /core/images/user.jpg
  images/*
  # Игнорирование ВСЕХ html-файлов в ОДНОЙ КОНКРЕТНОЙ директории(НЕ ВКЛЮЧАЯ   поддиректории)
  # Например /private/index.html
  # НЕ БУДУТ проигнорированы файлы в /private/ivan/index.html
  /private/*.html
  # Игнорирование ВСЕХ html-файлов в КОНКРЕТНОЙ директории ВКЛЮЧАЯ поддиректории
  # Например /private/info.html, /private/users/ivan/info.html
  /private/**/*.html
  # ---- РАЗНОЕ ----
  # Исключение из игнорирования
  # Игнорирование ВСЕХ файлов и папок внутри директории /secret,
  # за исключением файла /secret/free.txt, он не будет проигнорирован
  /secret/*
  !/secret/free.txt
  # Игнорирование файла с именем, содержащим спецсимволы
  # Например !readme!.txt
  \!readme!.txt
  # Игнорирование всех JPG и JPEG файлов внутри директорий,
  # которые начинаются на "h" и МОГУТ содержать ещё один символ после
  # Например /images/h4/user.jpg, /images/h/company.jpeg
  /images/h?/*.jp?g

`Если не нашёл решение" <https://git-scm.com/book/ru/v2>`_


BASH
~~~~~~~

BASH — Bourne-Again SHell (что может переводится как «перерожденный шел», или «Снова шел Борна(создатель sh)»), самый популярный командный интерпретатор в юниксоподобных системах, в особенности в GNU/Linux.

Команды 
"""""""""" 

.. code-block:: bash

  break # выход из цикла for, while или until  
  continue # выполнение следующей итерации цикла for, while или until  
  echo # вывод аргументов, разделенных пробелами, на стандартное устройство вывода  
  exit # выход из оболочки  
  export # отмечает аргументы как переменные для передачи в дочерние процессы в среде  
  hash # запоминает полные имена путей команд, указанных в качестве аргументов, чтобы не искать их при следующем обращении  
  kill # посылает сигнал завершения процессу  
  pwd # выводит текущий рабочий каталог  
  read # читает строку из ввода оболочки и использует ее для присвоения значений указанным переменным.\  
  return # заставляет функцию оболочки выйти с указанным значением  
  shift # перемещает позиционные параметры налево  
  test # вычисляет условное выражение  
  times # выводит имя пользователя и системное время, использованное оболочкой и ее потомками  
  trap # указывает команды, которые должны выполняться при получении оболочкой сигнала  
  unset # вызывает уничтожение переменных оболочки  
  wait # ждет выхода из дочернего процесса и сообщает выходное состояние.  

.. warning::

  Любой bash-скрипт должен начинаться со строки
  **#!/bin/bash**
  *в этой строке после #! указывается путь к bash-интерпретатору, поэтому если он у вас установлен в другом месте(где, вы можете узнать набрав `whereis bash`) поменяйте её на ваш путь.*


Переменные и параметры скрипта
""""""""""""""""""""""""""""""""

.. code-block:: bash

  #присваиваем переменной parametr1 значение первого параметра скрипта  
  parametr1=$1
  #присваиваем переменной script_name значение имени скрипта  
  script_name=$0
  # команда echo выводит определенную строку, обращение к переменным осуществляется через $имя_переменной.  
  echo "Вы запустили скрипт с именем $script_name и параметром $parametr1"
  # здесь мы видим другие кавычки, разница в том, что в одинарных кавычках не происходит подстановки переменных.  
  echo 'Вы запустили скрипт с именем $script_name и параметром $parametr1'

Зарезервированные переменные
""""""""""""""""""""""""""""""  

.. code-block:: bash

  $DIRSTACK # содержимое вершины стека каталогов  
  $EDITOR # текстовый редактор по умолчанию  
  $EUID # Эффективный UID. Если вы использовали программу su для выполнения команд от другого пользователя, то эта переменная содержит UID этого пользователя, в то время как...  
  $UID # ...содержит реальный идентификатор, который устанавливается только при логине.  
  $FUNCNAME # имя текущей функции в скрипте.  
  $GROUPS # массив групп к которым принадлежит текущий пользователь  
  $HOME # домашний каталог пользователя  
  $HOSTNAME # ваш hostname  
  $HOSTTYPE # архитектура машины.  
  $LC_CTYPE # внутренняя переменная, котороя определяет кодировку символов  
  $OLDPWD # прежний рабочий каталог  
  $OSTYPE # тип ОС  
  $PATH # путь поиска программ  
  $PPID # идентификатор родительского процесса  
  $SECONDS # время работы скрипта(в сек.)  
  $# # общее количество параметров переданных скрипту  
  $* # все аргументы переданыне скрипту(выводятся в строку)  
  $@ # тоже самое, что и предыдущий, но параметры выводятся в столбик  
  $! # PID последнего запущенного в фоне процесса  
  $$ # PID самого скрипта  

Условия
"""""""""""


> `#!/bin/bash`  
> \#в переменную source засовываем первый параметр скрипта  
> `source=$1`  
> \#в переменную dest засовываем второй параметр скрипта  
> `dest=$2`  
>
> \# в ковычках указываем имена переменных для сравнения. -eq - логическое сравнение обозначающие "равны"  
> `if [[ "$source" -eq "$dest" ]]`  
> \# если они действительно равны, то  
> `then`  
> \#выводим сообщение об ошибке, т.к. $source и $dest у нас равны  
> `echo "Применик $dest и источник $source один и тот же файл!"`  
> \# выходим с ошибкой (1 - код ошибки)  
> `exit 1`  
> \# если же они не равны  
> `else`  
> \# то выполняем команду cp: копируем источник в приемник  
> `cp $source $dest`  
> `echo "Удачное копирование!"`  
> `fi` #обозначаем окончание условия.  


Результат выполнения скрипта:


> `ite@ite-desktop:~$ ./primer2.sh 1 1`  
> Применик 1 и источник 1 один и тот же файл!  

> `ite@ite-desktop:~$ ./primer2.sh 1 2`  
> Удачное копирование!  

Структура `if-then-else` используется следующим образом:  

> `if` <команда или набор команд возвращающих код возврата(0 или 1)>  
> `then`  
> <если выражение после if истино, то выполняется этот блок>  
> `else`  
> <если выражение после if ложно, тот этот>  


В качестве команд возвращающих код возврата могут выступать структуры `[[ , [ , test, (( ))` или любая другая(или несколько) linux-команда.  


> `test` - используется для логического сравнения. после выражения, неоьбходима закрывающая скобка "]"  
>`[` - синоним команды test  
>`[[` - расширенная версия "[" (начиная с версии 2.02)(как в примере), внутри которой могут быть использованы || (или), & (и). Долна иметь закрывающуб скобку "]]"  
>`(( ))` - математическое сравнение.  


для построения многоярусных условий вида:

> `if ...`  
>`then ....`  
>`else`  
>`if ....`  
>`then....`  
>`else ....`  

для краткости и читаемости кода, можно использовать структуру:

> `if ..`  
> `then ...`  
> `elif ...`  
> `then ...`  
> `elif ...`  


## Условия. Множественный выбор

Если необходимо сравнивать какоую-то одну переменную с большим количеством параметров, то целесообразней использовать оператор case.

> `#!/bin/bash`  
> `echo "Выберите редатор для запуска:"`  
> `echo "1 Запуск программы nano"`  
> `echo "2 Запуск программы vi"`  
> `echo "3 Запуск программы emacs"`  
> `echo "4 Выход"`  
\#здесь мы читаем в переменную $doing со стандартного ввода  
> `read doing`  
>
> `case $doing in`  
> `1)`  
> `/usr/bin/nano` # если $doing содержит 1, то запустить nano  
> `;;`  
> `2)`  
> `/usr/bin/vi` # если $doing содержит 2, то запустить vi  
> `;;`  
> `3)`  
> `/usr/bin/emacs` # если $doing содержит 3, то запустить emacs  
> `;;`  
> `4)`  
> `exit 0`  
> `;;`  
> `*)` #если введено с клавиатуры то, что в case не описывается, выполнять следующее:  
> `echo "Введено неправильное действие"`  
>
> `esac` #окончание оператора case.  

Результат работы:

> `ite@ite-desktop:~$ ./menu2.sh`  
> Выберите редатор для запуска:  
> 1 Запуск программы nano  
> 2 Запуск программы vi  
> 3 Запуск программы emacs  
> 4 Выход  

После выбор цифры и нажатия Enter запуститься тот редактор, который вы выбрали(если конечно все пути указаны правильно, и у вас установлены эти редакторы :) )  


Прведу список логических операторв, которые используются для конструкции if-then-else-fi:

> `-z` # строка пуста  
> `-n` # строка не пуста  
> `=, (==)` # строки равны  
> `!=` # строки неравны  
> `-eq` # равно  
> `-ne` # неравно  
> `-lt,(< )` # меньше  
> `-le,(<=)` # меньше или равно  
> `-gt,(>)` #больше  
> `-ge,(>=)` #больше или равно  
> `!` #отрицание логического выражения  
> `-a,(&&)` #логическое «И»  
> `-o,(||)` # логическое «ИЛИ»  

   

  
  




 