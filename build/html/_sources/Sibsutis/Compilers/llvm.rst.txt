LLVM: инфраструктура для разработки компилятора
==================================================

Установка LLVM
~~~~~~~~~~~~~~~
* Склонировать репозиторий с LLVM:

.. code-block :: bash 

  git clone https://github.com/llvm/llvm-project.git
  #git clone --branch llvmorg-10.0.1 --depth 1 https://github.com/llvm/llvm-project.git
  

* Конфигурирование сборочных файлов:

 :: 

  cd llvm-project 

  mkdir build

  cd build

  cmake -G <generator> [options] ../llvm


 Generators:


  Ninja — для генерации ninja-build сборочных файлов

  Unix Makefiles — для генерации make поддерживающих parallel makefiles

  Visual Studio — for generating Visual Studio projects and solutions
 
  Xcode — for generating Xcode projects

 Options:

        -DLLVM_ENABLE_PROJECTS = '...' — semicolon-separated list of the LLVM subprojects you’d like to additionally build. Can include any of: clang, clang-tools-extra, libcxx, libcxxabi, libunwind, lldb, compiler-rt, lld, polly, or debuginfo-tests

        *For example* : -DLLVM_ENABLE_PROJECTS="clang;libcxx;libcxxabi"


        -DCMAKE_INSTALL_PREFIX=directory — Specify for directory the full pathname of where you want the LLVM tools and libraries to be installed (default /usr/local)

        -DCMAKE_BUILD_TYPE=type — Valid options for type are Debug, Release, RelWithDebInfo, and MinSizeRel. Default is Debug.

        -DLLVM_ENABLE_ASSERTIONS=On — Compile with assertion checks enabled (default is Yes for Debug builds, No for all other build types)


* Запуск сборки:

 :: 

  cmake --build .
  cmake --build --target install

Примечания:

 #. Собирать на каком-либо теге
 #. Можно выкачивать не весь репозиторий, см. опцию - -depth в гите
 #. При сборке нужно включить проект clang в -DLLVM_ENABLE_PROJECTS
 #. Собирать Debug версию (по умолчанию)
 #. Для сборки мне понадоби лось 8 GB Ram + 50 GB файлов подкачки + 70 GB свободного места
 #. Требуется cmake >= 3.13.4, python >= 2.7, gcc >= 5.1.0, ninja-build


Инструменты и организация
~~~~~~~~~~~~~~~~~~~~~~~~~~

Проект LLVM включает несколько библиотек и инструментов, которые, все вместе, образуют больщую инфраструктуру компилятора. Философия LLVM "все сущее есть библиотека". Это фреймворк со множеством инструментов позволяющий изучать/проходить все стадии компиляции

**10 лет тому назад** реализация, в значительной степени состоящая из алгоритмов трансляции в машинный код, опиралась на GCC, для трансляции программ в промежуточное представление LLVM (IR)

В философии LLVM есть важный аспект, компилятор (clang) не применяет оптимизаций во время компиляции, оставляя возможность выполнения оптимизаций в то время, когда программа не работает (н: во время компоновки)


**Конкуренция с Java**  Для поддержки оптимизации на всем жизненном цикле программы необходимо их распространение в формате LLVM IR, это предполагает работу LLVM как виртуальной машины и конкуренцию с Java

**Но** LLVM IR(внутреннее представление) не является системно-независимой, к тому же в LLVM отсутствует оптимизация с обратной связью

LLVM сегодня
"""""""""""""""
.. figure:: img/structure.png
    :width: 600 px
    :align: center

Части инфраструктуры:

 * **Анализатор исходного кода (frontend "clang"):** Компилятор, выполняющий этап трансляции программ на языках C, C++,.. в промежуточное представление LLVM IR. Включает лексический, синтаксический и семантический анализаторы, а также генератор кода LLVM IR
 * **Промежуточное представление (IR):** Промежуточное представление LLVM IR имеет две формы: удобночитаемую текстовую форму и двоичную
 * **Генератор выполняемого кода (backend "asm, JIT"):** Компилятор, преобразующий промежуточное представление LLVM IR программы в конкретный код на языке ассемблера для заданной архитектуры или в двоичный объектный код.

.. figure:: img/deep_structure.png
    :width: 600 px
    :align: center

Все компоненты компилятора взаимодействуют друг с другом 2-мя способами:

 #. **Через структуры в памяти:** Clang использует каждый компонент LLVM как библиотеку и опирается на структуру данных в памяти

 #. **Через файлы:** Пользователь запускает отдельные инструменты и использует их выходные файлы как входные файлы для последующих инструментов

Взаимодействие с драйвером компилятора
""""""""""""""""""""""""""""""""""""""""

Драйвер компилятора можно сравнить с официантом в ресторане, он принимает ваш заказ, передёт его повару и затем приносит готовое блюдо. В LLVM и Clang функции драйвера компилятора выполняет инструмент *clang*

Чтобы увидеть, какие инструменты вызываются драйвером, добавьте команду-аргумент -###

.. code-block:: bash

  clang -### hello.c -o hello
  clang version 3.4 (tags/RELEASE_34/final 211335)
  Target: i386-pc-linux-gui
  Thread model: posix
  “clang” “-cc1” (...parameters) “hello.c” “-o” “/tmp/hello-dddafc1.o”
  “/usr/bin/ld” (...parameters) “/tmp/hello-dddafc1.o” “-o” “hello”

 
* clang -cc1 реализует весь цикл компиляции

.. figure:: img/clang.png
    :width: 600 px
    :align: center


Использование автономных инструментов
"""""""""""""""""""""""""""""""""""""""

Тот же самый процесс компиляции, можно выполнить с использованием автономных инструментов LLVM, передавая вывод одного инструмента на ввод другого. Скорость компиляции уменьшится, но появляется возможность тонкой настройки параметров промежуточных инструментов:

 * **opt:** выполняет оптимизацию программы на уровне промежуточного представления IR. На входе файл с биткодом, на выходе файл того же типа  
 * **llc:** выполняет преобразование биткода в исходный текст на языке ассемблера для данной архитектуры. Принимает аргументы, опредеяющие уровень оптимизации
 * **llvm-mc:** выполняет трансляцию ассемблерного кода и может создавать объектные файлы (ELF, Mach, PE). Может также дизассемблировать файлы, приводя ассемблерный код во внутренние конструкции LLVM
 * **lli:** реализует интепретатор и JIT компилятор для IR
 * *llvm-link:* выполняет компоновку нескольких файлов с биткодом в один большой файл с биткодом LLVM
 * **llvm-as:** преобразует файлы с промежуточными представлением IR в текстовом виде (сборки LLVM), в файлы с биткодом LLVM
 * **llvm-dis:** декодирует биткод LLVM в сборки LLVM

Как это работает?
""""""""""""""""""

.. code-block:: c

  // main.c
  #include <stdio.h>

  int sum(int x, int y);

  int main() {
    int r = sum(3, 4);
    printf("r = %d\n",r);
    return 0;
  }

.. code-block:: c

  // sum.c

  int sum(int x, int y) {
    return x+y;
  }


.. code-block:: bash

  # 1. можно скомпилировать все одной командой:
  clang main.c sum.c -o sum 
  
  # 2.1 Тот же результат можно получить с помощью автономных инструментов:
  clang -emit-llvm -c main.c -o main.bc // получение биткод формы
  clang -emit-llvm -c sum.c -o sum.bc   // или
  clang -emit-llvm -S main.c -o main.ll // получение читаемой формы
  clang -emit-llvm -S sum.c -o sum.ll

  # 2.2a Преобразовать биткод в объектные файлы, далее создать исполняемый файл путем компоновки
  llc -filetype=obj main.bc -o main.o
  llc -filetype=obj sum.bc -o main.o
  clang main.o sum.o -o sum

  # 2.2b Сначала скомпоновать файлы с биткодом в 1 файл, затем преобразовать его в объектный файл
  # и из него получить исполняемый файл
  llvm-link main.bc sum.bc -o sum.linked.bc
  llc -filetype=obj sum.linked.bc -o sum.linked.o
  clang sum.linked.o -o sum


.. figure:: img/llvm-o.png
    :width: 600 px
    :align: center

Приемы программирования на C++ в LLVM
""""""""""""""""""""""""""""""""""""""""

Библиотеки и инструменты LLVM написаны на языке C++ с использованием преимуществ ООП (Полиморфизма, Наследования, Инкапсуляции), а также шаблонов (template). C полным списком эффективных приемов программирования на C++, используемых в LLVM можно ознакомиться `здесь <http://llvm.org/docs/CodingStandards.html>`_

Демонстрация расширяемого интерфейса проходов
"""""""""""""""""""""""""""""""""""""""""""""""

Под "проходом" в данном случае понимается анализ преобразования или оптимизации. LLVM API позволяет регистрировать собственные проходы на разных этапах компиляции. Регистрация проходов выполняются с помощью диспетчера проходов *PassManager* 

.. code-block:: c

  bool X86PassConfig::addPreEmitPass() {
    if(getOptLevel() != CodeGenOpt::None && getX86Subtarget().hasSSE2()) {
      addPass(createExecutionDependencyFixPass(&X86::VR128RegClass));
    }
    if(getOptLevel() != CodeGenOpt::None &&
      getX86Subtarget().padShortFunctions()) {
      addPass(createX86PadShortFunctions());
    }
  ...
  }

TableGen(.td)
""""""""""""""""""

Инструмент LLVM, используемый системой сборки, что бы сгенерировать программный код с++ для тех частей компилятора, которые могут быть синтезированы механическим способом

.. code-block:: bash

  //DiagnosticRarseKinds.td
  def err_invalid_sign_spec: Error<”’%0’ cannot be signed or unsigned”>;
  def err_invalid_short_spec: Error<”’short %0’ is invalid”>;

.. note::

  Цель TableGen - помочь человеку разрабатывать и поддерживать
  записи информации о предметной области. Поскольку таких
  записей может быть большое количество, он специально
  разработан, чтобы позволить писать гибкие описания и
  вычеркивать общие особенности этих записей. Это уменьшает
  количество дублирования в описании, снижает вероятность
  ошибки и упрощает структурирование информации, относящейся
  к предметной области.
  Основная часть TableGen анализирует файл, создает экземпляры
  объявлений и передает результат на обработку в «бэкэнд
  TableGen», зависящий от домена. В настоящее время основным
  пользователем TableGen является генератор кода LLVM. В случае каких либо вопросов обращайтесь к `документации  <https://releases.llvm.org/9.0.0/docs/TableGen/LangRef.html>`_


Анализатор исходного кода
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Подобно названию LLVM, имеющему несколько значений, название Clang также может использоваться в трех разных смыслах:
 
 #. Анализатор исходного кода

 #. Драйвер компилятора

 #. Фактический компилятор (clang -cc1)
 
Инструмент clang -cc1 имеет специальный параметр для вывода абстрактного синтаксического дерева (AST)

.. code-block:: bash

  clang -Xclang -ast-dump hello.c
  # или
  clang -сс1 -ast-dump hello.c

Библиотеки libclang:

 * **linclangLex**: используется для предварительной обработки и лексического анализа
 * **libclangAST**: содержит функции для построения и управления абстрактных синтаксических деревьев
 * **libclangParse**: используется для парсинга результатов фазы лексического анализа
 * **libclangSema**: используется для семантического анализа
 * **libclangCodeGen**: генерирует код промежуточного представления LLVM IR с использованием информации о целевой архитектуре
 * **libclangAnalysis**: содержит ресурсы для статического анализа
 * **libclangRewrite**: содержит инфраструктуру для реализации инструментов рефакторинга кода
 * **libclangBasic**: содержит множество утилит - абстракции управлния памятью, поиск источников данных и диагностика

Лексический анализ
""""""""""""""""""""

На самом первом этапе анализатор исходного кода разбивает языковые конструкции в текстовом формате на множество слов и лексем, удаляя такие элементы программы, как комментарии, пробелы и табуляции. Каждое слово должно принадлежать подможеству языка, а каждое зарезервированное слово преобразуется во внутреннее представление компилятора. Зарезервированные слова определены в файле *include/clang/Basic/TokenKinds.def* (Определения помещаются в пространство имён tok.т.е доступ к ним можно получить например: **tok::l_brace** и тд)

.. code-block:: c

  // C99 6.4.2: Identifiers.
  TOK(identifier) // abcde123
  // C++11 String Literals.
  TOK(utf32_string_literal)// U"foo"

  PUNCTUATOR(r_paren,")")
  PUNCTUATOR(l_brace,"{")
  PUNCTUATOR(less, "<")
  KEYWORD(while, KEYALL)



Инструменты Clang и фреймворк LibToling
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Инструменты Clang опираются на фреймворк LibToling, библиотеку Clang, которая может служить основой для создания автономных интсрументов

Инструменты на базе libTooling:

 * Clang Tidy
 * Clang Modernizer
 * Clang Apply Replacements
 * ClangFormat
 * Modularize
 * PPTrace
 * Clang Query


Clang-tidy
""""""""""""""""""

Данный инструмент проверяет наличие в исходном коде распространенных нарушений
стандартов оформления в том числе. Инструмент просматривает дерево AST и действует намного быстрее. В отличие от средств проверки в составе статического анализатора Clang, проверки написанные для clang-tidy, обычно нацелены на определения соответствия или несоответствия определенным соглашениям по оформлению исходного кода:

 * Переносимость кода между разными компиляторами;
 * Следование определенным идиомам;
 * Возможность появления ошибок из-за злоупотребления опасными особенностями языка

Проверка исходного кода с помощью Clang-tidy:

.. code-block:: bash

  clang-tidy [параметры] [<файл0>..<файлN>] [--команды компилятора]
  # можно воспользоваться * в параметре -checks для запуска множества проверок
  clang-tidy -checks="llvm-*" file.cpp

Так как наш код компилируется вместе с Clang, нам потребуется база данных команды компиляции. Поэтому начнем с её создания. Перейдите в каталог, где находятся исходные тексты LLVM, и создайте отдельный каталог для хранения файлов CMake

.. code-block:: bash

  mkdir cmake-scripts
  cd cmake-scripts
  cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ../llvm

.. tip::
  Если вы столкнетесь с ошибкой, сообщающей о неизвестном исходном файле и          ссылающейся на файл с реализацией нашего средства проверки, созданный в прерыдущей главе, просто добавьте имя этого файла в *CMakeLists.txt*. Для этого выполните следующую команду и запустите CMake еще раз

.. code-block:: bash

    vim ../llvm/tools/clang/lib/StaticAnalyzer/Checkers/CMakeLists.txt

Затем в корневом каталоге LLVM создайте ссылку на файл базы данных команд компиляции

.. code-block:: bash

  ln -s $(pwd)/compile_commands.json ../llvm
  # Теперь можно вызвать сам инструмент
  cd ../llvm/tools/clang/lib/StaticAnalyzer/Checkers
  clang-tidy -checks="llvm-*" ReactorChecker.cpp

Пример по использованию clang-tidy:

.. code-block:: bash

  clang-tidy test.cpp --fix-errors --fix
  -checks=bugprone-*,cppcoreguidelines-*,misc-*,modernize-*,performance-*,readability-* --

Было:

.. code-block:: bash

  #include <stdio.h>
  int main() {
    int i;
    printf (“%d”, i);
  }


Стало:

.. code-block:: c

  #include <cstdio>
  auto main() -> int {
    int i = 0;
    printf ("%d", i);
  }


Clang Modernizer
"""""""""""""""""""
  
**Clang Modernizer** = это революционный инструмент, цель которого помочь польщователям адаптировать старый код на С++ под новейшие стандарты:

 * **преобразование циклов:** циклы в старом С for (;;), преобразуются в более новые циклы вида: for (auto &...:..)
 * **преобразование пустых указателей:** константы NULL и 0, используемые для представления пустых указателей, замещаются nullptr (C++11)
 * **преобразование с добавлением ключевого слова auto:** в некоторые объявляения включается ключевое слово *auto* для повышения читаемости кода
 *  **преобразование с добавлением ключевого слова override:** добавляет в объявление методов, переопределяющих виртуальные методы родительских классов, спецификатор override
 * **преобразование передачи аргументов по значению:** передача константных ссылок замещается передачей по значени с выполнением операции копирования
 * **преобразование с заменой auto_ptr:** замещает старые автоматические указатели std::auto_ptr на std::unique_ptr

Пример по использованию clang-modernizer:

.. code-block:: bash

  clang-modernize [параметры] <файл0> [... <файлN>] [--<команда компилятора>]


Clang Apply Replacements 
""""""""""""""""""""""""""""

Данный интструмент отвечает за чтение файлов с поправками (Clang Modernize), отсеивает протиречивые и повторяющиеся поправки, и применяет их к файлам с исходными текстами.

Пример запуска:

* Чтобы опробовать Clang Apply Replacements нам нужно сначало воспользоваться Clang Modernizer и сохранить его поправки в файл

.. code-block:: c++

  int main() {
    const int size = 5;
    int arr[] = {1,2,3,4,5};
    for (int i = 0; i < size; ++i) {
      arr[i] += 5;
    }
    return 0;
  }


* Согласно руководству к Clang-Modernize, этот цикл можно безопасно преобразовать в цикл с помощью auto. Для этого следует выполнить:

.. code-block:: bash

  clang-modernize -loop-convert -serialize-replacements test.cpp --serialize-dir=./

* Чтобы применить исправления, надо выполнить команду:

.. code-block:: bash

  clang-apply-replacements


ClangFormat
"""""""""""""

Реализация форматирования кода в соответствии с соглашениями Инструмент, позволяющий разбить код на 80-символьные строки и улучшить его удобочитаемость.

Пример запуска:

.. code-block:: c++

  // test.cpp
  #include <cstdio>
  int main() {int i = 0;printf("%d", i);printf("%d", i);printf("%d",
  i);printf("%d", i);printf("%d", i);printf("%d", i);printf("%d",
  i);printf("%d", i); return 0;}


* Запускаем команду:

.. code-block:: bash
  
  # clang-format -style=LLVM -dump-config > .clang-format
  clang-format --style-LLVM test.cpp

* Результат: 

.. code-block:: c++

  #include <cstdio>
  int main() {
  int i = 0;
  printf("%d", i);
  printf("%d", i);
  printf("%d", i);
  printf("%d", i);
  printf("%d", i);
  printf("%d", i);
  printf("%d", i);
  printf("%d", i);
  return 0;
  }

Modularize
"""""""""""""

Целью этого инструмента является оказание помощи в решении задачи внедрения модулей. Он анализирует множество заголовочных файлов и сообщает, если обнаруживает повторяющиеся определения переменных, макросов или определения макросов, которые могут приводить к разным результатам

Пример запуска: 

* Создадим файл list.txt:


.. code-block:: bash

  gamelogic.h
  screenlogic.h

* Теперь достаточно запустить modularize и передвать ему файл:

.. code-block:: bash

  modularize list.txt

* Если изменить один из заголовочных файлов, включив в него символы из другого заголовочного файла, modularize сообщит, что проект опирается на небезопасное для модулей поведение, и что следует исправить проблему перед повторной попыткой создать файл module.modulemap

Module Map Checker
"""""""""""""""""""""

Инструмент исследует файл module.modulemap, проверяя - охватывае ли он все заголовочные файлы в каталоге

* Пример запуска:

.. code-block:: bash

  module-map-checker module.modulemap

PPTrace
""""""""""
.. epigraph::

 "Танцует в тесном контакте с лекическим аназизатором, чтобы обеспечивать эффективнуб предварительную обработку лексем"

Вывод трассировочной информации о работе препроцессора. Достигается это за счет реализации функций обратного вызова в интерфейсе clang::PPCallbacks
 
Он начинает с регистрации самого себя в роли «наблюдателя» за препроцессором и затем запускает анализ файлов. Информация о всех действиях препроцессора, таких как интерпретация директивы #if, импортирование модуля, подключение заголовочного файла и многих других, выводится на экран

Пример запуска:


.. code-block:: c++

  // hello.cpp
  #if 0
  #include
  #endif
  #ifdef CAPITALIZE
  #define WORLD "WORLD"
  #else
  #define WORLD "world"
  #endif
  extern int write(int, const char*,
  unsigned long);
  int main() {
    write(1, "Hello, ", 7);
    write(1, WORLD, 5);
    write(1, "!\n", 2);
    return 0;
  }

* Запускаем инструмент:

.. code-block:: bash

  pp-trace hello.c

* В результате возникает серия событий препроцессора, касающихся определния макросов, еще до того, как начнется фактическая обработка исходного файла:

.. code-block:: bash

  -Callback: if
   Loc: "hello.c:1:2"
   ConditionRange: [:"hello.c:1:4", "hello.c:2:1"]
   CondiotionValue: CVK_False
   ..

Clang-Query
"""""""""""""

Дает возможность исследовать дерево AST программы и отыскивать его сегменты по заданным условиям. Читает исходные файлы и интерактивно запрашивать узлы дерева AST. Выявляет узлы AST, соответствующие заданным условиям. Список доступных предикатов можно найти в заголовочном файле ASTMatchers.h.
Предполагает наличие базы данных команд компиляции.

Пример запуска:

.. code-block:: bash

  clang-query hello.c --

* После запука, инструмент выведет интерактивное приглашение к вводу, ожидая команд. Теперь можно вести команду match и имя предиката. Например, следующая команда требует от clang-query вывести все узлы типа CallExpr:


.. code-block:: bash

  clang-query> match callExpr()

  Match #1
  hello.c:12:5: note: "root" node binds here
    write(1, "Hello, ", 7);
    ^~~~~~~~~~~~~~~~~~~~~~~

Cписок команд:

* help: выводит список доступных команд;
* match <имя предиката> или m <имя предиката>: выполняет обход дерева AST и выполняет поиск узлов, соответствующих указанному предикату;
* set output <(diag | print | dump)>: определяет, как будет выводиться информация о найденных узлах
   * Параметр diag (действует по умолчанию) обеспечивает вывод диагностических сообщений для найденных узлов.
   * Параметр print обеспечивает простой вывод соответствующего фрагмента исходного кода.
   * Параметр dump обеспечивает вызов метода dump(),который дополнительно выводит все дочерние узлы



Clang-Check
""""""""""""""""

Clang-Check позволяет выполнять парсинг исходного кода на C/C++ и выводить дерево AST или выполнять простые проверки. Он также может применять «исправления», предлагаемые Clang, используя инфраструктуру, построенную на основе Clang Modernizer

Чтобы получить дерево AST для файла:

.. code-block:: bash

  clang-check <Имя_файла> -ast-dump -- 


Удаление вызовов c_str() "Самый маленький инструмент для рефакторинга"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Инструмент *remove-cstr-calls*  - это просто пример инструмента преобразование исходных текстов, то есть, инструмента рефакторинга. Он ищет избыточные вызовы метода c_str() обьектов str::string и удаляет их.

Такие вызовы считаются избыточными когда:

* когда новый объект string создается с вызовом метода c_str() другого объекта string. Например **std::string(myString.c_str())**. Эту операцию можно упростить за счет использования конструктора копии: **std::string(myString)**
* когда на основе объектов string создаются новые экземпляры классов LLVM StringRef и Twine. В этих случаях предпочтительнее использовать сам обьект string, а не результат вызова c_str(), то есть: **StringRef(myString)** вместо **StringRef(myString).c_str()**


Создание собственного инструмента (libclang)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Проект Clang предоставляет 3 интерфейса для доступа к функциональным возможностям Clang:

* **libclang:** является основным интерфейсом к механизмам Clang. Поддерживает обратную совместимость, обеспечивая работоспособность существующего ПО после выхода новой версии *libclang*
* **Clang Plugins:** позволяет добавлять свои проходы непосредственно в процедуру компиляции
* **LibTooling** позволяет создавать самостоятельные инструменты, предназначенные для выполнения рефакторинга кода или проверки синтаксиса. В отличии от libclang менее надежен с точки зрения поддержки обратной совместимости, но зато дает полный доступ к структуре дерева AST

Пример создание инструмента:

#. Найдите каталог *llvm-project/clang-tools-extra/*. Там лежит *tool-template*. В нём Cmake и код. Для написания собственного инструмента достаточно написать код на cpp и изменить имя в Cmake. Tool должен лежать тоже в этом каталоге

#. Назовем наш инструмент *cxxgrep*, он будет способен различать конструкции языка *C++*. Пример опций:

.. code-block:: bash

 -function  # Filter by functions
 -i         # Make the search case-insensitive
 -member    # Filter by members
 -parameter # Filter by function parameter
 -record    # Filter by records (class/struct)
 -variable  # Filter by variables

LLVM IR
~~~~~~~~~~~~~~

**LLVM IR** - промежуточное представление, магистраль связываюшая анализаторы исходного кода и генераторы выполняемого кода, которая позволяет LLVM анализировать програму на разных языках программирования и генерировать код для разных целевых архитектур

**SSA (Single Static Assignments)**
 * трехадресные инструкции
 * бесконечное множество регистров

Имея общее промежуточное представление, можно реализовать комплекс оптимизаций, независимо от поддерживаемых архитектур, но это требует поднять уровень IR

Промежуточное представление IR имеет три эквивалентные формы:

 * представление в памяти (класс *Instruction*)
 * представление на диске в файле **биткода**
 * представление на диске в удобочитаемом **текстовом формате**


.. code-block:: bash
  
  clang name.c -emit-llvm -c -o name.bc #Генерация биткода файла

  clang name.c -emit-llvm -S -c -o name.ll #Генерация читаемого представления LLVM IR

  llvm-as name.ll -o name.bc #Сборку преобразовать в бит-код

  llvm-dis name.bc -o name.ll #бит-код в сборку

  llvm-extract -func=sum sum.bc -o sum-fn.bc #Извлечь функцию sum из файла sum.bc


C/C++ имеют врожденную зависимость от платформы, при подключении заголовочных файлов, неявно подключаются файлы из каталога bits, который является собственным для каждой архитектуры. Если программа использует стандартные заголовочные файлы то уже на этапе AST мы зависим от архитектуры, что усложняет написание независимого IR

Содержание .ll файла
""""""""""""""""""""""

Подготовим .ll файл

.. code-block:: c

  int sum(int a, int b) {
    return a + b;
  }

.. code-block:: c

  clang -c example.cpp  -O0 --target=xcore -emit-llvm -S -o add_o0.ll


.. code-block:: bash

  ; ModuleID = 'example.cpp'
  source_filename = "example.cpp"
  target datalayout = "e-m:e-p:32:32-i1:8:32-i8:8:32-i16:16:32-i64:32-f64:32-a:0:32-n32"
  target triple = "xcore"
  
  ; Function Attrs: noinline nounwind optnone
  define dso_local i32 @_Z3sumii(i32 %a, i32 %b) #0 {
  entry:
    %a.addr = alloca i32, align 4
    %b.addr = alloca i32, align 4
    store i32 %a, i32* %a.addr, align 4
    store i32 %b, i32* %b.addr, align 4
    %0 = load i32, i32* %a.addr, align 4
    %1 = load i32, i32* %b.addr, align 4
    %add = add nsw i32 %0, %1
    ret i32 %add
  }
  
  attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
  
  !llvm.module.flags = !{!0}
  !llvm.ident = !{!1}

  !0 = !{i32 1, !"wchar_size", i32 1}
  !1 = !{!"clang version 10.0.1 (https://github.com/llvm/llvm-project.git ef32c611aa214dea855364efd7ba451ec5ec3f74)"}



Для примера было выбрано ядро процессора xcore, так как он не имеет каких-либо сложных особенностей при компиляции в IR-код, поэтому является идеальным объектом для исследований. Это ядро имеет разрядность 32, и clang выравнивает все переменные по границам 32-битных слов

Модуль - это структура данных LLVM IR верхнего уровня. Каждый модуль содержит последовательность функций, каждая из которых состоит из группы базовых блоков, которые в свою очередь содержат последовательности инструкций. Модуль также включает глобальные переменные, определение формата данных, прототипы внешних функций объявление структур данных

**Модуль:**
 * Глобальные переменные/определение функций 
 * Функции
    * Базовые блоки
       * Инструкции
 * Атрибуты

Локальные значения LLVM являются аналогами регистров в языке ассемблера и могут иметь любые имена, начинающиеся с символа %. Инструкция складывает локальные значения %0 и %1, и сохраняет результат в %add

.. code-block:: bash

  %add = add nsw i32 %0, %1

Конструкция *target datalayout* содержит информацию о порядке следования байтов (endianness) и размерах типов для триады *target triple*, описывающей целевой хост. Некоторые виды оптимизации зависят от формата данных.


.. code-block:: bash

  ; ModuleID = 'example.cpp' # название модуля
  source_filename = "example.cpp" # путь к файлу
  target datalayout = "e-m:e-p:32:32-i1:8:32-i8:8:32-i16:16:32-i64:32-f64:32-a:0:32-n32"
  target triple = "xcore"


* Целевой платформой является **xcore**. Данные в памяти хранятся в формате little-endian (e). На архитектурах с big-endian первой будет следовать буева (E)
* Информация о типах имеет формат: *type: <size> : <abi> : <preferred>*. Определение **p:32:32** в предыдущем примере представляет указатель, имеющий размер 32 бита, *abi* указыват на минимально необходимое выравнивание для типа, *preferred* - наибольшее возможное выравнивание.

Определение функций в .ll
"""""""""""""""""""""""""""

.. code-block:: bash

  define i32 @sum (i32 %a, i32 %b) { # упрощенная форма
  define dso_local i32 @_Z3sumii(i32 %a, i32 %b) #0 { # сгенерированая форма из примера


Эта функция возвращает значения типа i32 и принимает два аргумента типа i32, %a и %b. **Локальные идентификаторы всегда должны начинаться с символа %**, а **глобальные - с символа @**

Наиболее важные типы данных:
 * целые числа произвольного размера в форме *iN* (i32, i64)
 * вещественные числа, *float* 32-разрядные одинарной точности, *double* 64-разрядные двойной точности
 * векторные типы, определения которых имеет вид: <n_elements x elements_type>. Тип соответсвующий вектору с четырьмя элементами типа i32 определяется как <4 x i32> 

Атрибуты
""""""""""

.. code-block:: bash

   attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false"
   "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0"
   "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false"
   "no-trapping-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }

Тег *#0* в определении функции отображается в множество атрибутов функции. Множество атрибутов определяется в конце файла

 * noinline - функция которая не встраивается
 * nounwind - функции которые не порождают исключений
 * uwtable - требование раскрутки циклов
 * optnone - большинство проходов оптимизаций пропускают эту функцию
 * https://llvm.org/docs/LangRef.html - можно помотреть множество аттрибутов

Тело функции явно разделено на **базовые блоки(Basic Blocks, BB)** и каждый новый блок начинается с метки. Метка связана с базовым блоком, точно так же, как и идентификатор значения инструкции. Если метка опущена, ассемблер LLVM сгенерирует её, опираясь на собственные соглашения  об именовании
Базовый блок - это последовательность инструкций с единственной точкой входа в первой инструкции и единственной точйно выхода в последней инструкции. То есть, когда код выполняет переход к метке, соответсвующей базовому блоку, можно быть уверенными, что будут выполнены все инструкции в этом блоке, от первой до последней, причем последняя инструкция направит поток выполнения к другому блоку. Базовые блоки и соответсвующие им метки должны соответствовать условиям:

 * каждый базовый блок должен завершаться инструкцией, выполняющей переход к следующему базовому блоку или возврат из функции
 * первый базовый блок, который еще называют блоком вхожа - играет особую роль в функциях LLVM и не должен использоваться как цель

Инструкции
"""""""""""""

.. code-block:: c

  entry:
      %a.addr = alloca i32, align 4
      %b.addr = alloca i32, align 4
      store i32 %a, i32* %a.addr, align 4
      store i32 %b, i32* %b.addr, align 4
      %0 = load i32, i32* %a.addr, align 4
      %1 = load i32, i32* %b.addr, align 4
      %add = add nsw i32 %0, %1
      ret i32 %add

* Инструкция **alloca** резервирует пространство в кадре стека текущей функции. Обьем пространства определяется размером типа элемента с учетом указанного выравнивания. Первая инструкция * %a.addr = alloca i32, align 4*, выделяет место на стеке для 4-байтного элемента с выравниванием по границе 4 байт. Указатель на элемент в стеке сохраняется в локальном идентификаторе *%a.addr*

* Аргументы %a и %b сохраняются на стеке, по адресам %a.addr и %b.addr с помощью инструкии **store**
* Загрузка значений выполняется инструкциями **load**
* Эти значения используются в операции сложения *%add = add nsw i32 %0, %1*. И результат функции add, возвращается из функции **ret**. Флаг *nsw* указывает, что данная операция сложения не должна проверять перенос в знаковый бит (no signed wrap)
* Инструкции *load* и *store* являются избыточными - аргументы функции можно использовать в инструкции *add* непосредственно. Сlang использует по умолчанию уровень оптимизации -O0, поэтому избыточные инструкции не удаляться. А если скомпилировать с -O1, на выходе получится более простой код:

Пример файла с циклом:

.. code-block:: bash

  define i32 @sum(i32 %a, i32 %b) {
  entry:
    %add = add nsw i32 %b, %a
    ret i32 %add
  }

Пример файла с циклом:

.. code-block:: c

  int for_loop(int x[]) {
    int sum = 0;
    for(int i = 0; i < 10; ++i) {
      sum += x[i];
    }
    return sum;
  }

.. code-block:: bash

  clang -c example.cpp  -O0 --target=xcore -emit-llvm -S -o add_o0.ll

.. code-block:: bash

  ; ModuleID = 'example.cpp'
  source_filename = "example.cpp"
  target datalayout = "e-m:e-p:32:32-i1:8:32-i8:8:32-i16:16:32-i64:32-f64:32-a:0:32-n32"
  target triple = "xcore"

  ; Function Attrs: noinline nounwind optnone
  define dso_local i32 @_Z8for_loopPi(i32* %x) #0 {
  entry:
    %x.addr = alloca i32*, align 4
    %sum = alloca i32, align 4
    %i = alloca i32, align 4
    store i32* %x, i32** %x.addr, align 4
    store i32 0, i32* %sum, align 4
    store i32 0, i32* %i, align 4
    br label %for.cond

  for.cond:                                         ; preds = %for.inc, %entry
    %0 = load i32, i32* %i, align 4
    %cmp = icmp slt i32 %0, 10
    br i1 %cmp, label %for.body, label %for.end

  for.body:                                    ; preds = %for.cond
    %1 = load i32*, i32** %x.addr, align 4
    %2 = load i32, i32* %i, align 4
    %arrayidx = getelementptr inbounds i32, i32* %1, i32 %2
    %3 = load i32, i32* %arrayidx, align 4
    %4 = load i32, i32* %sum, align 4
    %add = add nsw i32 %4, %3
    store i32 %add, i32* %sum, align 4
    br label %for.inc

  for.inc:                                   ; preds = %for.body
    %5 = load i32, i32* %i, align 4
    %inc = add nsw i32 %5, 1
    store i32 %inc, i32* %i, align 4
    br label %for.cond

  for.end:                                   ; preds = %for.cond
    %6 = load i32, i32* %sum, align 4
    ret i32 %6
  }

  attributes #0 = { noinline nounwind optnone ... }

  !llvm.module.flags = !{!0}
  !llvm.ident = !{!1}

  !0 = !{i32 1, !"wchar_size", i32 1}
  !1 = !{!"clang version 10.0.1 (https://github.com/llvm/llvm-project.git ef32c611aa214dea855364efd7ba451ec5ec3f74)"}


* **Финода**- конструкция для определения значения переменной в зависимости от какого-то условия. В контексте SSA в зависимости от блока из которого мы пришли. *phi i32 [ 0, %0 ], [ %5, %1 ]*. Это означает, что функция примет значение 0, если переход произошёл с базового блока %0 (первый базовый блок в функции), и значение переменной %5, если переход произошёл с базового блока %1 (т.е. с выходной точки этого же базового блока)


Оптимизации времени компиляции и времени компоновки
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Clang и Opt: -O0, -O1, -O2, -O3, -Os, -Oz

Дополнительный уровень оптимизации Clang -O4

* -O4 - влаг оптимизаций типа -O3 с дополнительным флагом -flto (оптимизации времени компоновки)
* -Ox - определяет уровень оптимизаций
* -O0 - отсутствие оптимизаций
* -Os и -Oz - Такие же как и -O2 с дополнительными оптимизациями для уменьшения объема выполняемого кода
* -O2 - уровень умеренной оптимизации, включает в себя большинство из доступных
* -O3 - Такой же как -O2, дополнительно включающий оптимизации на которые требуется больше времени или которые приводят к увеличению объема кода.


Используемая литература
~~~~~~~~~~~~~~~~~~~~~~~~~~~

`LLVM. Инфраструктура для разработки компиляторов <LLVMbook.pdf>`_