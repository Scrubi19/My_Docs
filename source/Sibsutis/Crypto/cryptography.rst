Криптографические методы защиты информации
============================================


Криптосистемы с открытым ключом
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Возведение в степень по модулю
"""""""""""""""""""""""""""""""""

Односторонняя функция (англ. one-way function, OWF) -   математическая функция, которая легко вычисляется для любого входного значения, но трудно найти аргумент по заданному значению функции. В криптографических задачах в качестве односторонней функции часто используется функция:

.. math::
   { y = a^{x}\bmod p }

Обратная функция называется дискретным логарифмом и является трудновычислимой:

.. math::
   { x = log_a(y)\bmod p }

.. figure:: img/2.1.png
    :width: 650 px
    :align: center
    :alt: table

Элементы теории чисел
""""""""""""""""""""""""""

* Число называется простым, если оно не делится ни на какое другое число, кроме самого себя и единицы (11, 23)
* Любое целое положительное число  может быть представлено в виде произведения простых чисел, причем единственным образом (27 = 3*3 * 3,33)
* Два числа называются взаимно простыми если они не имеют ни одного общего делителя кроме единицы (27 и 28)
* **Функция Эйлера**. Пусть дано целое число N >= 1. Значение функции Эйлера ф(N) равно количеству чисел в ряду 1,2,3, ... ,N - 1, взаимно простых с N

 .. figure:: img/2.2.png
    :width: 600 px
    :align: center
    :alt: phi

 * Если p-простое число, то phi(p) = p - 1

 * Если p и q - два различных простых числа ( p != q). Тогда

.. math::
  { \varphi(pq) = (p-1)(q-1)}

* **Теорема Ферма**. Пусть p - простое число и 0 < a < p. Тогда

.. math::
   { a^{p-1}\bmod p = 1 }

* **Теорема Эйлера**. Пусть a и b - взаимно простые числа. Тогда 

.. math::
   { a^{\varphi(b)}\bmod b = 1 }


Обобщенный алгоритм Эвклида
""""""""""""""""""""""""""""""

Пусть a и b — два целых положительных числа. Наибольший общий делитель чисел a и b есть наибольшее число c, которое делит и a и b :

  .. math::
   { c = gcd(a, b) }

.. figure:: img/gcd.png
    :width: 600 px
    :align: center
    :alt: gcd

Пусть a и b — два целых положительных числа. Тогда существуют целые (не обязательно положительные) числа x и y , такие, что

  .. math::
   { ax + by = gcd(a, b) }

Введем три строки U = (u 1 , u 2 , u 3 ), V = (v 1 , v 2 , v 3 ) и T = (t 1 , t 2 , t 3 ). Тогда алгоритм записывается следующим образом:

.. figure:: img/Euclid.png
    :width: 600 px
    :align: center
    :alt: Euclid

Система Диффи-Хеллмана
""""""""""""""""""""""""""

Для обеспечения высокой стойкости рассмотренной системы число p-1 должно обязательно содержать большой простой множитель. Рекомендуют использовать следующее:

  .. math::
   { P = 2Q + 1 ,}

 где Q-простое число

Для Q должны выполняться условия:

  .. math::
   { 1 < G < P − 1  \quad и \quad G^{Q}\bmod P != 1 }


Согласно малой теореме Ферма можно утверждать,что если для какого-то числа a < P выполняется условие **a^(P-1)mod P != 1** ,  то число  является составным. Исходя из данного утверждения, можно легко разработать тест Ферма для проверки на простоту: :: 

 bool testFerma(long long p, int k) {
  if(p==2) return true;
  if(p&1)  return false;
  for(int i=0; i<k; ++i) {
    long long a=rand()%(P-1)+1;
    if(gcd(a,p)!=1 || powMod(a,p-1,p)!=1)
      return false;
  }
  return true;
 }


Абоненты выбирают большие числа Xa, Xb, Xc, которые храняться в секрете. Каждый абонент вычисляет соответсвующее число Y, которое открыто передается другим абонентам

.. math::
   \begin {cases} {Y_A = g^{X_A} \bmod p} \\
      {Y_B = g^{X_B} \bmod p} \\
      {Y_C = g^{X_C} \bmod p} \\
     \end {cases}

Допустим, абонент A решил организовать сеанс связи с B, при этом обоим абонентам доступна открытая информация (P, G, Y). Абонент A сообщает B по открытому каналу, что он хочет передать ему сообщение. Затем абонент A вычисляет величину:

.. math:: 
  {Z_{AB} = (Y_B)^{X_A} \bmod p}

В свою очередь, абонент B вычисляет число:

.. math:: 
  {Z_{BA} = (Y_A)^{X_B} \bmod p}

Получаем что:

.. math:: 
  {Z_{BA} = Z_{AB} }

Доказательство:

.. math:: 
  {Z_{AB} = (Y_B)^{X_A} \bmod p = (g^{X_B})^{X_A} \bmod p = \\
      = g^{X_A X_B} \bmod p = (Y_A)^{X_B} \bmod p = Z_{BA} }

Пример:
  Пусть P = 23 = 2 · 11 + 1 (Q = 11). Выберем параметр G. Попробуем взять g = 3. Проверим: 3^11 mod 23 = 1 и значит, такое g не подходит. Возьмем g = 5. Проверим: 5^11 mod 23 = 22. Итак, мы выбрали параметры p = 23, g = 5. Теперь каждый абонент выбирает секретное число и вычисляет соответствующее ему открытое число. Пусть выбраны Xa = 7 , Xb = 13 . Вычисляем Ya = 5^7 mod 23 = 17, Yb = 5^13 mod 23 = 21. Пусть A и B решили сформировать общий секретный ключ. Для этого A вычисляет Zab = 21^7 mod 23 = 10, а B вычисляет Zba = 17^13 mod 23 = 10.Теперь они имеют общий ключ 10, который не передавался по каналу связи



Метод "шаг младенца, шаг великана"
""""""""""""""""""""""""""""""""""""

Задача поиска x, при известных a и y. Сначала берем два целых числа m и k, такие что

  .. math::
   { m * k > p, \quad m = k = \sqrt{p} + 1 }



Вычислим два ряда чисел:

  .. math::
   { y,ay,a^{2y},...a^{m-1}y \quad (\bmod p) }
   {   a^{m},a^{2m},...a^{km} \quad (\bmod p) }

  (все вычисления по модулю p)

Найдем такие i и j, для которых выполняется равенство

  .. math::
   { a^{im} = a^{i} * y }
   

Число x:

  .. math::
   { x = i * m - j }

Шифр Шамира
"""""""""""""""

Этот шифр, предложенный Шамиром (Adi Shamir), был первым, позволяющим организовать обмен секретными сообщениями по открытой линии связи для лиц, которые не имеют никаких защищен-
ных каналов и секретных ключей и, возможно, никогда не видели друг друга.

Пусть есть два абонента A и B, соединенные линией связи. A хочет передать сообщение m абоненту B так, чтобы никто не узнал его содержание. A выбирает случайное большое простое число P и открыто передает его B. Затем A выбирает два числа Ca и Da , такие, что


.. math::
  { C_A*D_A \bmod (P-1) = 1  \\
      C_B*D_B \bmod (P-1) = 1 }  

После этого A передает свое сообщение m. Если m < P, то сообщение передается сразу, если же m >= P, то сообщение разбивается на части. Рассмотрим случай m < P
**Шаг 1.** A вычисляет число

.. math::
  {x_1 = m^{C_A} \bmod p, }

**Шаг 2.** B получив x1, вычисляет

.. math::
  {x_2 = x_1^{C_B} \bmod p, }

**Шаг 3.** A вычисляет число

.. math::
  {x_3 = x_2^{D_A} \bmod p, }

**Шаг 4.** B получив x3, вычисляет

.. math::
  {x_4 = x_3^{D_B} \bmod p, }


Используемая литература
~~~~~~~~~~~~~~~~~~~~~~~~~
`Б.Я. Рябко, А.Н. Фионов. "Криптографические методы защиты информации" <ryabko_fionov_kriptograficheskie_metody_zashchity_i.pdf>`_